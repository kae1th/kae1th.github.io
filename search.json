[{"title":"Docker基本知识总结","url":"/2025/08/20/Docker%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","content":"容器知识图谱\n本文是学习《每天五分钟玩转Docker容器技术》的总结。是基础知识学习，熟悉docker容器技术，为了更好的研究docker相关漏洞。\n​\n‍\n容器的基本架构\n\nDocker客户端：Client​\nDocker服务器：Docker daemon​\nDocker镜像：Image​\nDocker仓库：Registry​\nDocker容器：Container​\n\n​\n通过docker我们可以方便地在Host上构建和运行容器。最常用的Docker客户端是docker命令。用户也可以通过REST API与服务器通信。\n常用的命令\n\n\n\n命令分类\n命令\n功能说明\n常用示例\n\n\n\n\n容器生命周期管理\n​docker run​​\n创建并启动容器\n​docker run -d -p 80:80 --name mynginx nginx（后台启动 nginx，映射 80 端口）\n\n\n\n​docker start [容器名/ID]​\n启动已停止的容器\n​docker start mynginx​\n\n\n\n​docker stop [容器名/ID]​\n停止运行中的容器（优雅关闭）\n​docker stop mynginx​\n\n\n\n​docker restart [容器名/ID]​\n重启容器\n​docker restart mynginx​\n\n\n\n​docker rm [容器名/ID]​\n删除容器（需先停止，-f 强制删除运行中容器）\n​docker rm -f mynginx​\n\n\n容器查看\n​docker ps​\n查看运行中的容器\n​docker ps -a（查看所有容器，包括已停止）\n\n\n\n​docker inspect [容器名/ID]​​\n查看容器详细信息（配置、网络等）\n​docker inspect mynginx​\n\n\n\n​docker logs [容器名/ID]​​\n查看容器日志（-f 实时跟踪，–tail 100 查看最后 100 行）\n​docker logs -f mynginx​\n\n\n容器操作\n​docker exec -it [容器名/ID] [命令]​​\n进入运行中的容器并执行命令（-it 交互模式）\n​docker exec -it mynginx /bin/bash（进入 bash 终端）\n\n\n\n​docker cp [本地路径] [容器名/ID]:[容器路径]​\n从本地复制文件到容器\n​docker cp ./test.txt mynginx:/tmp/​\n\n\n\n​docker cp [容器名/ID]:[容器路径] [本地路径]​\n从容器复制文件到本地\n​docker cp mynginx:/tmp/test.txt ./​\n\n\n\n​docker top [容器名/ID]​​\n查看容器内运行的进程\n​docker top mynginx​\n\n\n镜像管理\n​docker images​\n查看本地镜像\n​docker images -a（包括中间镜像）\n\n\n\n​docker pull [镜像名:标签]​\n从仓库拉取镜像\n​docker pull mysql:8.0​\n\n\n\n​docker push [镜像名:标签]​\n推送镜像到仓库（需先登录）\n​docker push myrepo/myimage:v1​\n\n\n\n​docker rmi [镜像名/ID]​\n删除本地镜像（-f 强制删除，需先删除依赖容器）\n​docker rmi -f nginx​\n\n\n\n​docker build -t [镜像名:标签] [Dockerfile路径]​\n基于 Dockerfile 构建镜像\n​docker build -t myapp:v1 .（当前目录的 Dockerfile）\n\n\n镜像信息\n​docker image inspect [镜像名/ID]​​\n查看镜像详细信息\n​docker image inspect nginx​\n\n\n\ndocker history [镜像名/ID]​​\n查看镜像构建历史（各层操作）\n​docker history nginx​\n\n\n仓库管理\n​docker login [仓库地址]​\n登录 Docker 仓库（默认 Docker Hub）\n​docker login（登录 Docker Hub）\n\n\n\n​docker logout [仓库地址]​\n退出仓库登录\n​docker logout​\n\n\n\n​docker search [关键词]​\n搜索仓库中的镜像\n​docker search python​\n\n\n数据卷管理\n​docker volume create [卷名]​\n创建数据卷（持久化存储）\n​docker volume create myvol​\n\n\n\n​docker volume ls​\n查看所有数据卷\n​docker volume ls​\n\n\n\n​docker volume inspect [卷名]​\n查看数据卷详细信息\n​docker inspect myvol​\n\n\n\n​docker volume rm [卷名]​\n删除数据卷\n​docker volume rm myvol​\n\n\n网络管理\n​docker network ls​\n查看 Docker 网络\n​docker network ls​\n\n\n\n​docker network create [网络名]​\n创建自定义网络（默认 bridge 模式）\n​docker network create mynet​\n\n\n\n​docker network connect [网络名] [容器名/ID]​\n将容器连接到指定网络\n​docker network connect mynet mynginx​\n\n\n\n​docker network disconnect [网络名] [容器名/ID]​\n断开容器与网络的连接\n​docker network disconnect mynet mynginx​\n\n\n系统信息\n​docker info​\n查看 Docker 系统信息（版本、镜像数、容器数等）\n​docker info​\n\n\n\n​docker version​\n查看 Docker 客户端和服务端版本\n​docker version​\n\n\n\n​\nREST API 需要Docker daemon配置开启端口，很多未授权漏洞就是这个原因：\n#Linux 系统 编辑 /etc/docker/daemon.json&#123;  &quot;hosts&quot;: [&quot;unix:///var/run/docker.sock&quot;, &quot;tcp://0.0.0.0:2375&quot;]&#125;Windows/macOS：通过 Docker Desktop 配置：进入 Settings → Docker Engine，在 JSON 配置中添加上述 hosts 字段，点击 Apply &amp; Restart。客户端连接：docker -H 192.168.56.102 info\n//安全配置1、TLS 证书认证,客户端使用证书认证访问API（网上随便都有教程不写了）2、最小权限原则：仅开放必要的 API 端口（2376），并限制来源 IP（通过防火墙）。3、定期轮换证书：TLS 证书设置较短有效期（如 90 天），定期更新。4、日志审计：开启 Docker 和反向代理（如果有）的访问日志，监控异常请求。5、使用网络隔离：将 Docker API 部署在私有网络，避免直接暴露公网。\nDocker镜像\nDockerfile是镜像的描述文件，定义了如何构建Docker镜像。\nFROM debianRUN apt-get install emacsRUN apt-get install apache2CMD [&quot;/bin/bash&quot;]\n新镜像是从base镜像(内核和host一样)一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层。分层结构最大的一个好处就是：共享资源\n​\n#构建镜像docker build -t [镜像名:标签] [Dockerfile路径]docker commit [选项] &lt;容器ID或名称&gt; &lt;新镜像名[:标签]&gt;  //现有容器打包成镜像#dockerfile语法FROM  \t\t#指定base镜像。MAINTAINER  #设置镜像的作者，可以是任意字符串。COPY  \t\t#将文件从build context复制到镜像。COPY src destADD \t\t#与COPY类似，不同的是，如果src是归档文件（tar、zip、tgz、xz等）文件会被自动解压到dest。ENV \t\t#设置环境变量，环境变量可被后面的指令使用。EXPOSE \t\t#指定容器中的进程会监听某个端口，Docker可以将该端口暴露出来。VOLUME \t\t#将文件或目录声明为volume。WORKDIR \t#为后面的RUN、CMD、ENTRYPOINT、ADD或COPY指令设置镜像中的当前工作目录。RUN \t\t#在容器中运行指定的命令。CMD \t\t#容器启动时运行指定的命令。Dockerfile中可以有多个CMD指令，但只有最后一个生效。CMD可以被dockerrun之后的参数替换。ENTRYPOINT \t#设置容器启动时运行的命令。Dockerfile中可以有多个ENTRYPOINT指令，但只有最后一个生效。CMD或docker run之后的参数会被当作参数传递给ENTRYPOINT。\nDocker容器\n镜像启动的实例。\n资源限制\n#内存限额 -m 或 --memorydocker run -m 200M --menmory-swap=300M ubantu#CPU限额 -c 或 --cpu-sharesdocker run --name A -c 1024 ubantu #Block IO带宽限额 限制容器写 /dev/sda的速率为30 MB/sdocker run -it --device-write-bps /dev/sda:30MB ubantu--device-read-bps：限制读某个设备的bps。--device-write-bps：限制写某个设备的bps。--device-read-iops：限制读某个设备的iops。--device-write-iops：限制写某个设备的iops。bps是byte per second，每秒读写的数据量。iops是io per second，每秒IO的次数。\n容器的底层技术\ncgroup实现资源限额，namespace实现资源隔离。\ncgroup\ncgroup全称Control Group。Linux操作系统通过cgroup可以设置进程使用CPU、内存和IO资源的限额。上面的 --cpu-shares、-m、–device-write-bps 实际上就是在配置cgroup。可以在宿主机或者容器内  /sys/fs/cgroup中找到它。有一个漏洞CVE-2022-0492（cgroup逃逸）， 这里不展开写。\n\nnamespace\n在每个容器中，我们都可以看到文件系统、网卡等资源，这些资源看上去是容器自己的。拿网卡来说，每个容器都会认为自己有一块独立的网卡，即使host上只有一块物理网卡。Linux实现这种方式的技术是namespace。namespace管理着host中全局唯一的资源，并可以让每个容器都觉得只有自己在使用它。换句话说，namespace实现了容器间资源的隔离。\nLinux使用了6种namespace，分别对应6种资源：Mount、UTS、IPC、PID、Network和User。\n\n\nMount namespace让容器看上去拥有整个文件系统。\n\n\nUTS namespace让容器有自己的hostname。\n\n\nIPC namespace让容器拥有自己的共享内存和信号量（semaphore）来实现进程间通信，而不会与host和其他容器的IPC混在一起。\n\n\nPID namespace 让容器在host中以进程的形式运行。例如当前host中运行了两个容器。通过宿主机 ps axf 可以查看容器进程。所有容器的进程都挂在dockerd进程下，同时也可以看到容器自己的子进程。\n\n\nNetwork namespace让容器拥有自己独立的网卡、IP、路由等资源。\n\n\nUser namespace让容器能够管理自己的用户，host不能看到容器中创建的用户。\n\n\nDocker网络\n单个host上的容器网络\nnone网络\nnone网络就是什么都没有的网络。挂在这个网络下的容器除了lo，没有其他任何网卡。\ndocker run -itd --network=none httpd\nhost网络\n连接到host网络的容器共享Docker host的网络栈，容器的网络配置与host完全一样。\ndocker run -itd --network=host httpddocker inspect 309d1004f38c&quot;NetworkMode&quot;: &quot;host&quot;\nbridge网络\nDocker安装时会创建一个命名为docker0的Linux bridge。如果不指定–network，创建的容器默认都会挂到docker0上。 brctl show可以看网卡\n\ndocker run -itd httpddocker inspect da9b1b378e0f&quot;NetworkMode&quot;: &quot;default&quot;\n​\nuser-defined网络\n用户也可以根据业务需要创建user-defined网络。\ndocker network create --driver bridge my_net 1docker network inspect1 my_net #查看        &quot;IPAM&quot;: &#123;            &quot;Driver&quot;: &quot;default&quot;,            &quot;Options&quot;: &#123;&#125;,            &quot;Config&quot;: [                &#123;                    &quot;Subnet&quot;: &quot;172.18.0.0/16&quot;,                    &quot;Gateway&quot;: &quot;172.18.0.1&quot;                &#125;            ]        &#125;,docker run -itd --network=my_net1 httpd#设置网络--subnet 172.22.16.0/24--gateway 172.22.16.1 #使用 --ip 指定IP 只有使用 --subnet创建的网络才能指定静态IP。docker network create --driver bridge my_net2 --subnet 172.22.16.0/24 --gateway 172.22.16.1 docker run -itd --network=my_net2 --ip 172.22.16.8 busybox\n不同的网卡 host 的 iptables 默认DROP 无法连通。如果需要连通，则需添加目标网络网卡\ndocker network connect my_net2 httpd容器ID\n容器间通信\n容器之间可通过IP, Docker DNS Server 或 joined 容器三种方式通信。两个容器要能通信，必须要有属于同一个网络的网卡。\n\n\nIP\n具体做法是在容器创建时通过 --network指定相应的网络，或者通过docker network connect将现有容器加入到指定网络。\n\n\nDocker DNS Server\ndocker daemon实现了一个内嵌的DNS server，使容器可以直接通过&quot;容器名&quot;通信。方法很简单，只要在启动时用 --name为容器命名就可以了。\n\n\njoined容器\njoined容器非常特别，它可以使两个或多个容器共享一个网络栈，共享网卡和配置信息，joined容器之间可以通过127.0.0.1直接通信。\ndocker run -d -it --name=web1 httpddocker run -it --network=container:web1 busybox#两个容器使用相同的网卡\n\n\n将容器与外部世界连接\n通过NAT, docker实现了容器对外网的访问。\n​\n（1）busybox发送ping包：172.17.0.2 &gt; www.bing.com。\n（2）docker0收到包，发现是发送到外网的，交给NAT处理。\n（3）NAT将源地址换成enp0s3的IP:10.0.2.15 &gt; www.bing.com。\n（4）ping包从enp0s3发送出去，到达www.bing.com。\n外部世界访问容器\ndocker可将容器对外提供服务的端口映射到host的某个端口，外网通过该端口访问容器。容器启动时通过-p参数映射端口。\ndocker run -d -p [host port]:[container port] httpd docker run -d -p 8080:80 httpd \n每一个映射的端口，host都会启动一个docker-proxy进程来处理访问容器的流量。\n​\n（1）docker-proxy监听host的32773端口。\n（2）当curl访问10.0.2.15:32773时，docker-proxy转发给容器172.17.0.2:80。\n（3）httpd容器响应请求并返回结果。\n‍\n跨多个host的网络\n跨主机网络方案：docker原生的overlay和macvlan; 第三方方案：常用的包括flannel、weave和calico。这些方案与docker集成是通过libnetwork、container network model​\nlibnetwork &amp; CNM\nlibnetwork是docker容器网络库，最核心的内容是其定义的Container Network Model（CNM）\n\nSandbox（类似存储interface、路由表和DNS设置的表）：Sandbox是容器的网络栈，包含容器的interface、路由表和DNS设置。LinuxNetwork Namespace是Sandbox的标准实现。Sandbox可以包含来自不同Network的Endpoint。\nEndpoint（类似网卡）：Endpoint的作用是将Sandbox接入Network。Endpoint的典型实现是veth pair，一个Endpoint只能属于一个网络，也只能属于一个Sandbox。\nNetwork（类似交换机）：Network包含一组Endpoint，同一Network的Endpoint可以直接通信。Network的实现可以是Linux Bridge、VLAN等。\n\nlibnetwork CNM定义了docker容器的网络模型，按照该模型开发出的driver就能与docker daemon协同工作，实现容器网络。\n​\noverlay\n容器跨主机通信，Docker提供了overlay driver，使用户可以创建基于VxLAN的overlay网络。VxLAN可将二层数据封装到UDP进行传输，VxLAN提供与VLAN相同的以太网二层服务，但是拥有更强的扩展性和灵活性。(就是新建了桥接网卡，容器可添加变为双网卡)\n#创建 docker network create   -d 指定网络driverdocker network create -d overlay ov_net1 \nmacvlan\nmacvlan本身是linux kernel模块，其功能是允许同一个物理网卡配置多个MAC地址，即多个interface，每个interface可以配置自己的IP。macvlan本质上是一种网卡虚拟化技术\ndocker network create -d macvlan --subnet=172.16.86.0/24 \\--gateway=172.16.86.1 -o parent=eth1 mac_net1-o parent指定使用的网络interface。\n\ndocker没有为macvlan提供DNS服务，这点与overlay网络是不同的。无法ping bbox1，只能通过IP。\nmacvlan网络是local网络，为了保证跨主机能够通信，用户一般需要自己管理IP subnet。\ndocker不会为macvlan创建网关，这里的网关应该是真实存在的，否则容器无法路由。\n\ndocker run -itd --name bbox1 --ip=172.16.86.10 --network nac_net1 busyboxdocker run -itd --name bbox2 --ip=172.16.86.11 --network nac_net1 busybox\nmacvlan不依赖Linux bridge, brctl show可以确认并没有创建新的bridge\n​\n用sub-interface实现多macvlan网络\nmacvlan会独占主机的网卡，也就是说一个网卡只能创建一个macvlan网络。macvlan不仅可以连接到interface（如enp0s9），也可以连接到sub-interface（如VLAN enp0s9.xxx）。\n不同macvlan网络之间不能通信。但准确的说法应该是：不同macvlan网络不能在二层上通信。在三层上可以通过网关将macvlan连通。可以借助中间网关连通。可以是物理路由，可以是某台主机配置的sub-interface网关IP。开启ip forward，以及iptables来充当虚拟路由器。\n如将Host 192.168.56.101配置成一个虚拟路由器，设置网关并转发VLAN10和VLAN20的流量。\n···\n//ip forward开启sysctl -w net.ipv4.ip_forward=1//在 /etc/network/interfaces中配置vlan sub-interfaceauto eth2 iface eth2 inet manualauto eth2.10 iface eth2.10 inet manual vlan-raw-device eth2auto eth2.20 iface eth2.20 inet manual vlan-raw-device eth2启用sub-interface：ifup eth2.10 ifup eth2.20//将网关IP配置到sub-interface：ifconfig eth2.10 172.16.10.1 netmask 255.255.255.0 up ifconfig eth2.20 172.16.20.1 netmask 255.255.255.0 up//添加iptables规则，转发不同VLAN的数据包。iptables -t nat -A POSTROUTING -o eth2.10 -j MASQUERADEiptables -t nat -A POSTROUTING -o eth2.20 -j MASQUERADEiptables -A FORWARD -i eth2.10-o eth2.20 -m state --state RELATED, ESTABLISHED -j ACCEPT iptables -A FORWARD -i eth2.20-o eth2.10 -m state --state RELATED, ESTABLISHED -j ACCEPTiptables -A FORWARD -i eth2.10-o eth2.20 -j ACCEPT iptables -A FORWARD -i eth2.20-o eth2.10 -j ACCEPT\n第三方需要特别搭建，文章篇幅不拓展了\nflannel\nflannel是CoreOS开发的容器网络解决方案。flannel为每个host分配一个subnet，容器从此subnet中分配IP，这些IP可以在host间路由，容器间无须NAT和portmapping就可以跨主机通信。同时没有隔离能力。\n每个subnet都是从一个更大的IP池中划分的，flannel会在每个主机上运行一个叫flanneld的agent，其职责就是从池子中分配subnet。为了在各个主机间共享信息，flannel用etcd（与consul类似的key-value分布式数据库）存放网络配置、已分配的subnet、host的IP等信息。\n‍\nweave\nweave是Weaveworks开发的容器网络解决方案。weave创建的虚拟网络可以将部署在多个主机上的容器连接起来。对容器来说，weave就像一个巨大的以太网交换机，所有容器都被接入这个交换机，容器可以直接通信，无须NAT和端口映射。除此之外，weave的DNS模块使容器可以通过hostname访问。weave不依赖分布式数据库（例如etcd和consul）交换网络信息，每个主机上只需运行weave组件就能建立起跨主机容器网络。\n默认配置下，weave使用一个大subnet（例如10.32.0.0/12），所有主机的容器都从这个地址空间中分配IP，因为同属一个subnet，容器可以直接通信。如果要实现网络隔离，可以通过环境变量WEAVE_CIDR为容器分配不同subnet的IP。\nweave是一个私有的VxLAN网络，默认与外部网络隔离。连通需要（1）首先将主机加入到weave网络。（2）然后把主机当作访问weave网络的网关。\n‍\ncalico\nCalico是一个纯三层的虚拟网络方案，Calico为每个容器分配一个IP，每个host都是router，把不同host的容器连接起来。与VxLAN不同的是，Calico不对数据包做额外封装，不需要NAT和端口映射，扩展性和性能都很好。Calico依赖etcd在不同主机间共享和交换信息，存储Calico网络状态。host192.168.56.101负责运行etcd。Calico网络中的每个主机都需要运行Calico组件，实现容器interface管理、动态路由、动态ACL、报告状态等。\n不同的calico网络，默认不能通行。calico默认的policy规则是：容器只能与同一个calico网络中的容器通信。\n‍\nDocker存储\nDocker为容器提供了两种存放数据的资源：由storage driver管理的镜像层和容器层和Data Volume​\nStorage driver\nstorage driver实现了多层数据的堆叠并为用户提供一个单一的合并之后的统一视图。Docker支持多种storage driver，有AUFS、Device Mapper、Btrfs、OverlayFS、VFS和ZFS。\n优先使用Linux发行版默认的storage driver。\nUbuntu默认driver用的是AUFS，底层文件系统是extfs\nRedhat/CentOS的默认driver是Device Mapper, SUSE则是Btrfs\n容器没有需要持久化的数据，随时可以从镜像直接创建。使用storage driver即可。\nData Volume\nData Volume本质上是Docker Host文件系统中的目录或文件，能够直接被mount到容器的文件系统中。\n（1）Data Volume是目录或文件，而非没有格式化的磁盘（块设备）。\n（2）容器可以读写volume中的数据。\n（3）volume数据可以被永久地保存，使用它的容器销毁不影响它。\n在具体的使用上，docker提供了两种类型的volume:bind mount和docker managed volume​\nbind mount\nbind mount是将host上已存在的目录或文件mount到容器。即使容器没有了，bind mount也还在。bind mount时还可以指定数据的读写权限，默认是可读可写，可指定为只读\n-v的格式为 &lt;host path&gt;:&lt;container path&gt;docker run -d -p 80:80 -v ~/htdocs:/usr/local/apache2/htdocs httpdro=Read-only 只有host有权修改数据，提高了安全性。docker run -d -p 80:80 -v ~/htdocs:/usr/local/apache2/htdocs:ro httpd\ndocker managed volume\ndocker managed volume与bind mount在使用上的最大区别是不需要指定mount源，随机在host生成。docker inspect 容器长ID 查看存储源位置。\ndocker run -d -p 80:80 -v /usr/local/apache2/htdocs httpd\n数据共享\n容器与host共享数据\n对于bind mount是非常明确的：直接将要共享的目录mount到容器。\ndocker managed volume就要麻烦点。由于volume位于host中的目录，是在容器启动时才生成，所以需要将共享数据复制到volume中。\ndocker run -d -p 80:80 -v /usr/local/apache2/htdocs httpddocker cp ~/htdocs/index.html 容器ID:/usr/local/apache2/htdocs\n容器之间共享数据\n将共享数据放在bind mount中，然后将其mount到多个容器。\ndocker run --name web1 -d -p 80 -v ~/htdocs:/usr/local/apache2/htdocs httpddocker run --name web2 -d -p 80 -v ~/htdocs:/usr/local/apache2/htdocs httpd\n另一种在容器之间共享数据的方式是使用volume container。volume container是专门为其他容器提供volume的容器。它提供的卷可以是bind mount，也可以是docker managed volume。\ndocker create vc_data \\-v ~/htdocs:/usr/local/apache2/htdocs \\-v /other/useful/tools httpddocker run --name web1 -d -p 80 -v ~/htdocs:/usr/local/apache2/htdocs httpd\n容器命名为vc_data，docker create命令，这是因为volume container的作用只是提供数据，它本身不需要处于运行状态。\n\n\nbind mount，存放Web Server的静态文件。\n\n\ndocker managed volume，存放一些实用工具\n\n\n其他容器可以通过--volumes-from使用vc_data这个volume container\n\n\ndocker run --name web1 -d -p 80 --volumes-from vc_data httpddocker run --name web2 -d -p 80 --volumes-from vc_data httpd\ndata-packed volume container 将数据完全放到volume container中，同时又能与其他容器共享。原理是将数据打包到镜像中，然后通过docker managed volume共享。\nFROM busybox:latestADD htdocs /usr/local/apache2/htdocsVOLUME /usr/local/apache2/htdocs//build新镜像datapackeddocker build -t datapacked .ADD将静态文件添加到容器目录 /usr/local/apache2/htdocs。VOLUME的作用与 -v 等效，用来创建docker managed volume,mount point 为/usr/local/apache2/htdocs因为这个目录就是ADD添加的目录，所以会将已有数据复制到volume中。//build新镜像datapackeddocker create --name vc_data datapacked\n因为在Dockerfile中已经使用了VOLUME指令，这里就不需要指定volume的mount point了,启动httpd容器并使用data-packed volume container。和volume container其实一样。\ndocker run --name web2 -d -p 80:80 --volumes-from vc_data httpd\n容器监控\n监控子命令：ps、top和stats，然后是几个功能更强的开源监控工具sysdig、Weave Scope、cAdvisor和Prometheus\n//监控子命令docker container ps docker container top 容器ID  //某个容器中运行了哪些进程docker container stats //用于显示每个容器各种资源的使用情况//sysdigdocker container run -it --rm --name=sysdig --privileged=true \\ --volume=/var/run/docker.sock:/host/var/run/docker.sock \\ --volume=/dev:/host/dev \\ --volume=/proc:/host/proc:ro \\ --volume=/boot:/host/boot:ro \\ --volume=/lib/modules:/host/lib/modules:ro\\ --volume=/usr:/host/usr:ro \\ sysdig/sysdig//Weave Scopecurl -L git.io/scope -o /usr/local/bin/scope chmod a+x /usr/local/bin/scope scope launch//cAdvisordocker run \\ --volume=/:/rootfs:ro \\ --volume=/var/run:/var/run:rw \\--volume=/sys:/sys:ro \\ --volume=/var/lib/docker/:/var/lib/docker:ro \\ --publish=8080:8080 \\ --detach=true \\ --name=cadvisor \\google/cadvisor:latest\nPrometheus提供了监控数据搜集、存储、处理、可视化和告警一套完整的解决方案。\n\nPrometheus Server：负责从Exporter拉取和存储监控数据，并提供一套灵活的查询语言（PromQL）供用户使用。\nExporter：负责收集目标对象（host、container等）的性能数据，并通过HTTP接口供Prometheus Server获取。\n可视化组件：Grafana能够与Prometheus无缝集成，提供完美的数据展示能力。\nAlertmanager：用户可以定义基于监控数据的告警规则，规则会触发告警。一旦Alertmanager收到告警，会通过预定义的方式发出告警通知。支持的方式包括Email、PagerDuty、Webhook等。\n\n​\n日志管理\nDocker logs\ndocker attach 容器ID  //只能记录attach执行后的日志 按Ctrl+p键，然后再按Ctrl+q键才能退出docker logs -f 容器ID\nELK\nELK是三个软件的合称：Elasticsearch、Logstash、Kibana。 Logstash-&gt;Elasticsearch-&gt;Kibana\n\nElasticsearch：一个近乎实时查询的全文搜索引擎。Elasticsearch的设计目标就是要能够处理和搜索巨量的日志数据。\nLogstash：读取原始日志，并对其进行分析和过滤，然后将其转发给其他组件（比如Elasticsearch）进行索引或存储。Logstash支持丰富的Input和Output类型，能够处理各种应用的日志。\nKibana：一个基于JavaScript的Web图形界面程序，专门用于可视化Elasticsearch的数据。Kibana能够查询Elasticsearch并通过丰富的图表展示结果。用户可以创建Dashboard来监控系统的日志。\n\ndocker run -p 5601:5601-p 9200:9200-p 5044:5044-it --name elk sebp/elk- 5601:Kibana web接口- 9200:Elasticsearch JSON接口- 5044:Logstash日志接收接口\n‍\n","categories":["云安全"]},{"title":"重新出发","url":"/2025/08/17/%E9%87%8D%E6%96%B0%E5%87%BA%E5%8F%91/","content":"重新出发\n今-2025年8月，一枚末流211本科毕业，从事网络安全相关工作5年的工程师（牛马），随着年龄、见识的增长，感觉前路有些许迷雾，重新搭建一个博客（避免熟人发现），梳理来路思考未来方向，跳出围城，不应该缺少重新出发的勇气。\n来时路\n2020年信息安全专业毕业，恰好遇上了口罩，毕业典礼都没有(ㄒoㄒ)。大学也确实没学到什么本事，家里没有人能给什么建议，想就业没有找实习，考研也没有想法，大学时懒惰，但是好在学习成绩还可以，靠着毕业设计的知识，勉强入职了家小公司做安全服务。\n初创公司就几个人，做的东西很多很杂，现在回想也很感谢当初的老板让我学会了很多。技术学会了渗透、应急、java代码审计，后来还给公司的研发搭建了完整的SDLC，小公司的工作内容包括(大牛马)：售前支持，售后执行，项目经理。\n\n售前支持：协助销售对接客户，参与需求沟通与方案讲解，结合客户业务场景提供针对性安全测试建议，支撑销售签单；\n售后执行：销售签单后，作为核心接口人对接客户，明确测试范围、获取系统权限、梳理业务流程等关键测试信息，确保测试方向与客户需求一致；\n项目经理：从项目启动到最终交付，全程负责进度把控、问题协调与结果验收，保障客户满意度。\n\n是的干的很多，很杂，很累，工资还低（比996狠）~~，公司从开始的6人到后来的70人。\n2022年7月。多种原因裸辞了，7月中旬开始投简历一直没有合适的机会，恰好HW要开始了，找朋友要了个机会，去了某个供电所值班（闲-休息）。行情好一天税后3.5K，很开心。HW之后所在地（保密）的工作机会确实太少，群里看到有北京的机会，一投就上岸了，是一家央企的子公司。\n2022年10月。第一次来北京，记得天气微凉，南方的人不太适应北京的干，买了加湿器，去了故宫，天安门，颐和园，然后居家了。。入职是正常的，8号就入职了，央企的福利还是不错了，加班也不多，一下子非常不习惯（🐂当多了）。工作内容也变得垂直：渗透测试、应急响应。也熟悉了一些漏洞管理、安全加固、合规相关的工作，从乙方安全服务转向了甲方安全建设。\n2025年8月。在这家公司工作了三年，考了PTS，后续应该会考CISSP。工作的内容已经变得程序化，机械化，感觉自己的可替代性太强了。公司流程规定的升职涨薪都没有落实，和朋友们聊天我现在的年薪是他们的1/3，差距还是挺大的，而且公司是市场化经营也不是那么稳，有10%的淘汰率，思考走人了，毕竟远离家乡就是赚钱来的。\n理思绪\n目前我的技能有攻防，应急，代码审计（刚拿起来，写前已经审计了两个CMS的洞了）。之前看到过这么一句话，人的精力有限，选择一个想做的方向去做到不可替代，攻防我感觉入行简单可替代性强，结合入行就一直有的理想，可以自己运营一家公司或者一个产品线的安全，就是想做安全架构师，看了看最新的发展（招聘），云计算和AI是目前最火的方向。安全一直都是锦上添花的，AI还没有那么成熟，云目前相对成熟。后续打算研究云相关的安全+代码审计+应急响应，加强自己的不可替代性。看到很多SDL在招聘，和我想做，能力图谱都和我的技能非常相近，农历25年底准备出击这个岗位，希望可以成功。\n谈规划\n写这篇总结，对于SDL只有初步的概念，认知还是有限，只能先做再调整。\n\n\n云常用组件漏洞原理、复现、修复知识学习。\n\nDocker、K8s、GitLab、Jenkins、Prometheus+Grafana、ELK\n\n\n\n代码审计能力持续强化\n\nJava利用链的学习和挖掘\nCodeQL使用，写出通用漏洞的规则\n\n\n\n搭建 DevSecOps 环境\n\n搭建环境\nOWASP Threat Dragon、SonarQube、OWASP Dependency-Check、Checkov、Clair学习\n\n\n\n‍\n‍\n","categories":["阶段总结"]},{"title":"categories","url":"/categories/index.html","content":"\n网络安全\n云安全\nSDL建设\n生活记录\n阶段总结\n\n"},{"title":"link","url":"/link/index.html","content":"欢迎交换友链~，联系邮箱：kaelth@126.com\n\n先知社区\n\n"}]